// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"golang-intern/assignment-2/ent/apireq"
	"golang-intern/assignment-2/ent/earthquake"
	"golang-intern/assignment-2/ent/featuretype"
	"golang-intern/assignment-2/ent/ftypeearthquake"
	"golang-intern/assignment-2/ent/geometry"
	"golang-intern/assignment-2/ent/location"
	"golang-intern/assignment-2/ent/predicate"
	"golang-intern/assignment-2/ent/report"
	"golang-intern/assignment-2/ent/schemamigration"
	"golang-intern/assignment-2/ent/source"
	"golang-intern/assignment-2/ent/sourceearthquake"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApireq           = "Apireq"
	TypeEarthquake       = "Earthquake"
	TypeFeatureType      = "FeatureType"
	TypeFtypeEarthquake  = "FtypeEarthquake"
	TypeGeometry         = "Geometry"
	TypeLocation         = "Location"
	TypeReport           = "Report"
	TypeSchemaMigration  = "SchemaMigration"
	TypeSource           = "Source"
	TypeSourceEarthquake = "SourceEarthquake"
)

// ApireqMutation represents an operation that mutates the Apireq nodes in the graph.
type ApireqMutation struct {
	config
	op            Op
	typ           string
	id            *int
	req_time      *time.Time
	req_param     *map[string]interface{}
	req_body      *map[string]interface{}
	req_headers   *map[string]interface{}
	req_metadata  *map[string]interface{}
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Apireq, error)
	predicates    []predicate.Apireq
}

var _ ent.Mutation = (*ApireqMutation)(nil)

// apireqOption allows management of the mutation configuration using functional options.
type apireqOption func(*ApireqMutation)

// newApireqMutation creates new mutation for the Apireq entity.
func newApireqMutation(c config, op Op, opts ...apireqOption) *ApireqMutation {
	m := &ApireqMutation{
		config:        c,
		op:            op,
		typ:           TypeApireq,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApireqID sets the ID field of the mutation.
func withApireqID(id int) apireqOption {
	return func(m *ApireqMutation) {
		var (
			err   error
			once  sync.Once
			value *Apireq
		)
		m.oldValue = func(ctx context.Context) (*Apireq, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Apireq.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApireq sets the old Apireq of the mutation.
func withApireq(node *Apireq) apireqOption {
	return func(m *ApireqMutation) {
		m.oldValue = func(context.Context) (*Apireq, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApireqMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApireqMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Apireq entities.
func (m *ApireqMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApireqMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApireqMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Apireq.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReqTime sets the "req_time" field.
func (m *ApireqMutation) SetReqTime(t time.Time) {
	m.req_time = &t
}

// ReqTime returns the value of the "req_time" field in the mutation.
func (m *ApireqMutation) ReqTime() (r time.Time, exists bool) {
	v := m.req_time
	if v == nil {
		return
	}
	return *v, true
}

// OldReqTime returns the old "req_time" field's value of the Apireq entity.
// If the Apireq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApireqMutation) OldReqTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReqTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReqTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqTime: %w", err)
	}
	return oldValue.ReqTime, nil
}

// ResetReqTime resets all changes to the "req_time" field.
func (m *ApireqMutation) ResetReqTime() {
	m.req_time = nil
}

// SetReqParam sets the "req_param" field.
func (m *ApireqMutation) SetReqParam(value map[string]interface{}) {
	m.req_param = &value
}

// ReqParam returns the value of the "req_param" field in the mutation.
func (m *ApireqMutation) ReqParam() (r map[string]interface{}, exists bool) {
	v := m.req_param
	if v == nil {
		return
	}
	return *v, true
}

// OldReqParam returns the old "req_param" field's value of the Apireq entity.
// If the Apireq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApireqMutation) OldReqParam(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReqParam is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReqParam requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqParam: %w", err)
	}
	return oldValue.ReqParam, nil
}

// ResetReqParam resets all changes to the "req_param" field.
func (m *ApireqMutation) ResetReqParam() {
	m.req_param = nil
}

// SetReqBody sets the "req_body" field.
func (m *ApireqMutation) SetReqBody(value map[string]interface{}) {
	m.req_body = &value
}

// ReqBody returns the value of the "req_body" field in the mutation.
func (m *ApireqMutation) ReqBody() (r map[string]interface{}, exists bool) {
	v := m.req_body
	if v == nil {
		return
	}
	return *v, true
}

// OldReqBody returns the old "req_body" field's value of the Apireq entity.
// If the Apireq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApireqMutation) OldReqBody(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReqBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReqBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqBody: %w", err)
	}
	return oldValue.ReqBody, nil
}

// ResetReqBody resets all changes to the "req_body" field.
func (m *ApireqMutation) ResetReqBody() {
	m.req_body = nil
}

// SetReqHeaders sets the "req_headers" field.
func (m *ApireqMutation) SetReqHeaders(value map[string]interface{}) {
	m.req_headers = &value
}

// ReqHeaders returns the value of the "req_headers" field in the mutation.
func (m *ApireqMutation) ReqHeaders() (r map[string]interface{}, exists bool) {
	v := m.req_headers
	if v == nil {
		return
	}
	return *v, true
}

// OldReqHeaders returns the old "req_headers" field's value of the Apireq entity.
// If the Apireq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApireqMutation) OldReqHeaders(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReqHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReqHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqHeaders: %w", err)
	}
	return oldValue.ReqHeaders, nil
}

// ResetReqHeaders resets all changes to the "req_headers" field.
func (m *ApireqMutation) ResetReqHeaders() {
	m.req_headers = nil
}

// SetReqMetadata sets the "req_metadata" field.
func (m *ApireqMutation) SetReqMetadata(value map[string]interface{}) {
	m.req_metadata = &value
}

// ReqMetadata returns the value of the "req_metadata" field in the mutation.
func (m *ApireqMutation) ReqMetadata() (r map[string]interface{}, exists bool) {
	v := m.req_metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldReqMetadata returns the old "req_metadata" field's value of the Apireq entity.
// If the Apireq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApireqMutation) OldReqMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReqMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReqMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReqMetadata: %w", err)
	}
	return oldValue.ReqMetadata, nil
}

// ResetReqMetadata resets all changes to the "req_metadata" field.
func (m *ApireqMutation) ResetReqMetadata() {
	m.req_metadata = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ApireqMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApireqMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Apireq entity.
// If the Apireq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApireqMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApireqMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApireqMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApireqMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Apireq entity.
// If the Apireq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApireqMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApireqMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ApireqMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ApireqMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Apireq entity.
// If the Apireq object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApireqMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ApireqMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[apireq.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ApireqMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[apireq.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ApireqMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, apireq.FieldDeletedAt)
}

// Where appends a list predicates to the ApireqMutation builder.
func (m *ApireqMutation) Where(ps ...predicate.Apireq) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApireqMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApireqMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Apireq, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApireqMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApireqMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Apireq).
func (m *ApireqMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApireqMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.req_time != nil {
		fields = append(fields, apireq.FieldReqTime)
	}
	if m.req_param != nil {
		fields = append(fields, apireq.FieldReqParam)
	}
	if m.req_body != nil {
		fields = append(fields, apireq.FieldReqBody)
	}
	if m.req_headers != nil {
		fields = append(fields, apireq.FieldReqHeaders)
	}
	if m.req_metadata != nil {
		fields = append(fields, apireq.FieldReqMetadata)
	}
	if m.created_at != nil {
		fields = append(fields, apireq.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apireq.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, apireq.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApireqMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apireq.FieldReqTime:
		return m.ReqTime()
	case apireq.FieldReqParam:
		return m.ReqParam()
	case apireq.FieldReqBody:
		return m.ReqBody()
	case apireq.FieldReqHeaders:
		return m.ReqHeaders()
	case apireq.FieldReqMetadata:
		return m.ReqMetadata()
	case apireq.FieldCreatedAt:
		return m.CreatedAt()
	case apireq.FieldUpdatedAt:
		return m.UpdatedAt()
	case apireq.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApireqMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apireq.FieldReqTime:
		return m.OldReqTime(ctx)
	case apireq.FieldReqParam:
		return m.OldReqParam(ctx)
	case apireq.FieldReqBody:
		return m.OldReqBody(ctx)
	case apireq.FieldReqHeaders:
		return m.OldReqHeaders(ctx)
	case apireq.FieldReqMetadata:
		return m.OldReqMetadata(ctx)
	case apireq.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apireq.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apireq.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Apireq field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApireqMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apireq.FieldReqTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqTime(v)
		return nil
	case apireq.FieldReqParam:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqParam(v)
		return nil
	case apireq.FieldReqBody:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqBody(v)
		return nil
	case apireq.FieldReqHeaders:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqHeaders(v)
		return nil
	case apireq.FieldReqMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReqMetadata(v)
		return nil
	case apireq.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apireq.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apireq.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Apireq field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApireqMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApireqMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApireqMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Apireq numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApireqMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apireq.FieldDeletedAt) {
		fields = append(fields, apireq.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApireqMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApireqMutation) ClearField(name string) error {
	switch name {
	case apireq.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Apireq nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApireqMutation) ResetField(name string) error {
	switch name {
	case apireq.FieldReqTime:
		m.ResetReqTime()
		return nil
	case apireq.FieldReqParam:
		m.ResetReqParam()
		return nil
	case apireq.FieldReqBody:
		m.ResetReqBody()
		return nil
	case apireq.FieldReqHeaders:
		m.ResetReqHeaders()
		return nil
	case apireq.FieldReqMetadata:
		m.ResetReqMetadata()
		return nil
	case apireq.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apireq.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apireq.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Apireq field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApireqMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApireqMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApireqMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApireqMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApireqMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApireqMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApireqMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Apireq unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApireqMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Apireq edge %s", name)
}

// EarthquakeMutation represents an operation that mutates the Earthquake nodes in the graph.
type EarthquakeMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	mag                       *float64
	addmag                    *float64
	time                      *time.Time
	updated_time              *time.Time
	tz                        *int32
	addtz                     *int32
	url                       *string
	detail                    *string
	status                    *string
	tsunami                   *int32
	addtsunami                *int32
	sig                       *int32
	addsig                    *int32
	net                       *string
	code                      *string
	nst                       *int32
	addnst                    *int32
	dmin                      *float64
	adddmin                   *float64
	rms                       *float64
	addrms                    *float64
	gap                       *float64
	addgap                    *float64
	mag_type                  *string
	eq_type                   *string
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	clearedFields             map[string]struct{}
	geometry                  *int
	clearedgeometry           bool
	report                    *int
	clearedreport             bool
	ftype_earthquakes         map[int]struct{}
	removedftype_earthquakes  map[int]struct{}
	clearedftype_earthquakes  bool
	source_earthquakes        map[int]struct{}
	removedsource_earthquakes map[int]struct{}
	clearedsource_earthquakes bool
	done                      bool
	oldValue                  func(context.Context) (*Earthquake, error)
	predicates                []predicate.Earthquake
}

var _ ent.Mutation = (*EarthquakeMutation)(nil)

// earthquakeOption allows management of the mutation configuration using functional options.
type earthquakeOption func(*EarthquakeMutation)

// newEarthquakeMutation creates new mutation for the Earthquake entity.
func newEarthquakeMutation(c config, op Op, opts ...earthquakeOption) *EarthquakeMutation {
	m := &EarthquakeMutation{
		config:        c,
		op:            op,
		typ:           TypeEarthquake,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEarthquakeID sets the ID field of the mutation.
func withEarthquakeID(id int) earthquakeOption {
	return func(m *EarthquakeMutation) {
		var (
			err   error
			once  sync.Once
			value *Earthquake
		)
		m.oldValue = func(ctx context.Context) (*Earthquake, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Earthquake.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEarthquake sets the old Earthquake of the mutation.
func withEarthquake(node *Earthquake) earthquakeOption {
	return func(m *EarthquakeMutation) {
		m.oldValue = func(context.Context) (*Earthquake, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EarthquakeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EarthquakeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Earthquake entities.
func (m *EarthquakeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EarthquakeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EarthquakeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Earthquake.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGeoID sets the "geo_id" field.
func (m *EarthquakeMutation) SetGeoID(i int) {
	m.geometry = &i
}

// GeoID returns the value of the "geo_id" field in the mutation.
func (m *EarthquakeMutation) GeoID() (r int, exists bool) {
	v := m.geometry
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoID returns the old "geo_id" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldGeoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoID: %w", err)
	}
	return oldValue.GeoID, nil
}

// ClearGeoID clears the value of the "geo_id" field.
func (m *EarthquakeMutation) ClearGeoID() {
	m.geometry = nil
	m.clearedFields[earthquake.FieldGeoID] = struct{}{}
}

// GeoIDCleared returns if the "geo_id" field was cleared in this mutation.
func (m *EarthquakeMutation) GeoIDCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldGeoID]
	return ok
}

// ResetGeoID resets all changes to the "geo_id" field.
func (m *EarthquakeMutation) ResetGeoID() {
	m.geometry = nil
	delete(m.clearedFields, earthquake.FieldGeoID)
}

// SetReportID sets the "report_id" field.
func (m *EarthquakeMutation) SetReportID(i int) {
	m.report = &i
}

// ReportID returns the value of the "report_id" field in the mutation.
func (m *EarthquakeMutation) ReportID() (r int, exists bool) {
	v := m.report
	if v == nil {
		return
	}
	return *v, true
}

// OldReportID returns the old "report_id" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldReportID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportID: %w", err)
	}
	return oldValue.ReportID, nil
}

// ClearReportID clears the value of the "report_id" field.
func (m *EarthquakeMutation) ClearReportID() {
	m.report = nil
	m.clearedFields[earthquake.FieldReportID] = struct{}{}
}

// ReportIDCleared returns if the "report_id" field was cleared in this mutation.
func (m *EarthquakeMutation) ReportIDCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldReportID]
	return ok
}

// ResetReportID resets all changes to the "report_id" field.
func (m *EarthquakeMutation) ResetReportID() {
	m.report = nil
	delete(m.clearedFields, earthquake.FieldReportID)
}

// SetMag sets the "mag" field.
func (m *EarthquakeMutation) SetMag(f float64) {
	m.mag = &f
	m.addmag = nil
}

// Mag returns the value of the "mag" field in the mutation.
func (m *EarthquakeMutation) Mag() (r float64, exists bool) {
	v := m.mag
	if v == nil {
		return
	}
	return *v, true
}

// OldMag returns the old "mag" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldMag(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMag: %w", err)
	}
	return oldValue.Mag, nil
}

// AddMag adds f to the "mag" field.
func (m *EarthquakeMutation) AddMag(f float64) {
	if m.addmag != nil {
		*m.addmag += f
	} else {
		m.addmag = &f
	}
}

// AddedMag returns the value that was added to the "mag" field in this mutation.
func (m *EarthquakeMutation) AddedMag() (r float64, exists bool) {
	v := m.addmag
	if v == nil {
		return
	}
	return *v, true
}

// ResetMag resets all changes to the "mag" field.
func (m *EarthquakeMutation) ResetMag() {
	m.mag = nil
	m.addmag = nil
}

// SetTime sets the "time" field.
func (m *EarthquakeMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *EarthquakeMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *EarthquakeMutation) ResetTime() {
	m.time = nil
}

// SetUpdatedTime sets the "updated_time" field.
func (m *EarthquakeMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *EarthquakeMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldUpdatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (m *EarthquakeMutation) ClearUpdatedTime() {
	m.updated_time = nil
	m.clearedFields[earthquake.FieldUpdatedTime] = struct{}{}
}

// UpdatedTimeCleared returns if the "updated_time" field was cleared in this mutation.
func (m *EarthquakeMutation) UpdatedTimeCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldUpdatedTime]
	return ok
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *EarthquakeMutation) ResetUpdatedTime() {
	m.updated_time = nil
	delete(m.clearedFields, earthquake.FieldUpdatedTime)
}

// SetTz sets the "tz" field.
func (m *EarthquakeMutation) SetTz(i int32) {
	m.tz = &i
	m.addtz = nil
}

// Tz returns the value of the "tz" field in the mutation.
func (m *EarthquakeMutation) Tz() (r int32, exists bool) {
	v := m.tz
	if v == nil {
		return
	}
	return *v, true
}

// OldTz returns the old "tz" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldTz(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTz is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTz requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTz: %w", err)
	}
	return oldValue.Tz, nil
}

// AddTz adds i to the "tz" field.
func (m *EarthquakeMutation) AddTz(i int32) {
	if m.addtz != nil {
		*m.addtz += i
	} else {
		m.addtz = &i
	}
}

// AddedTz returns the value that was added to the "tz" field in this mutation.
func (m *EarthquakeMutation) AddedTz() (r int32, exists bool) {
	v := m.addtz
	if v == nil {
		return
	}
	return *v, true
}

// ClearTz clears the value of the "tz" field.
func (m *EarthquakeMutation) ClearTz() {
	m.tz = nil
	m.addtz = nil
	m.clearedFields[earthquake.FieldTz] = struct{}{}
}

// TzCleared returns if the "tz" field was cleared in this mutation.
func (m *EarthquakeMutation) TzCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldTz]
	return ok
}

// ResetTz resets all changes to the "tz" field.
func (m *EarthquakeMutation) ResetTz() {
	m.tz = nil
	m.addtz = nil
	delete(m.clearedFields, earthquake.FieldTz)
}

// SetURL sets the "url" field.
func (m *EarthquakeMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *EarthquakeMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *EarthquakeMutation) ClearURL() {
	m.url = nil
	m.clearedFields[earthquake.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *EarthquakeMutation) URLCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *EarthquakeMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, earthquake.FieldURL)
}

// SetDetail sets the "detail" field.
func (m *EarthquakeMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *EarthquakeMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ClearDetail clears the value of the "detail" field.
func (m *EarthquakeMutation) ClearDetail() {
	m.detail = nil
	m.clearedFields[earthquake.FieldDetail] = struct{}{}
}

// DetailCleared returns if the "detail" field was cleared in this mutation.
func (m *EarthquakeMutation) DetailCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldDetail]
	return ok
}

// ResetDetail resets all changes to the "detail" field.
func (m *EarthquakeMutation) ResetDetail() {
	m.detail = nil
	delete(m.clearedFields, earthquake.FieldDetail)
}

// SetStatus sets the "status" field.
func (m *EarthquakeMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *EarthquakeMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *EarthquakeMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[earthquake.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *EarthquakeMutation) StatusCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *EarthquakeMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, earthquake.FieldStatus)
}

// SetTsunami sets the "tsunami" field.
func (m *EarthquakeMutation) SetTsunami(i int32) {
	m.tsunami = &i
	m.addtsunami = nil
}

// Tsunami returns the value of the "tsunami" field in the mutation.
func (m *EarthquakeMutation) Tsunami() (r int32, exists bool) {
	v := m.tsunami
	if v == nil {
		return
	}
	return *v, true
}

// OldTsunami returns the old "tsunami" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldTsunami(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTsunami is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTsunami requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTsunami: %w", err)
	}
	return oldValue.Tsunami, nil
}

// AddTsunami adds i to the "tsunami" field.
func (m *EarthquakeMutation) AddTsunami(i int32) {
	if m.addtsunami != nil {
		*m.addtsunami += i
	} else {
		m.addtsunami = &i
	}
}

// AddedTsunami returns the value that was added to the "tsunami" field in this mutation.
func (m *EarthquakeMutation) AddedTsunami() (r int32, exists bool) {
	v := m.addtsunami
	if v == nil {
		return
	}
	return *v, true
}

// ClearTsunami clears the value of the "tsunami" field.
func (m *EarthquakeMutation) ClearTsunami() {
	m.tsunami = nil
	m.addtsunami = nil
	m.clearedFields[earthquake.FieldTsunami] = struct{}{}
}

// TsunamiCleared returns if the "tsunami" field was cleared in this mutation.
func (m *EarthquakeMutation) TsunamiCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldTsunami]
	return ok
}

// ResetTsunami resets all changes to the "tsunami" field.
func (m *EarthquakeMutation) ResetTsunami() {
	m.tsunami = nil
	m.addtsunami = nil
	delete(m.clearedFields, earthquake.FieldTsunami)
}

// SetSig sets the "sig" field.
func (m *EarthquakeMutation) SetSig(i int32) {
	m.sig = &i
	m.addsig = nil
}

// Sig returns the value of the "sig" field in the mutation.
func (m *EarthquakeMutation) Sig() (r int32, exists bool) {
	v := m.sig
	if v == nil {
		return
	}
	return *v, true
}

// OldSig returns the old "sig" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldSig(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSig: %w", err)
	}
	return oldValue.Sig, nil
}

// AddSig adds i to the "sig" field.
func (m *EarthquakeMutation) AddSig(i int32) {
	if m.addsig != nil {
		*m.addsig += i
	} else {
		m.addsig = &i
	}
}

// AddedSig returns the value that was added to the "sig" field in this mutation.
func (m *EarthquakeMutation) AddedSig() (r int32, exists bool) {
	v := m.addsig
	if v == nil {
		return
	}
	return *v, true
}

// ClearSig clears the value of the "sig" field.
func (m *EarthquakeMutation) ClearSig() {
	m.sig = nil
	m.addsig = nil
	m.clearedFields[earthquake.FieldSig] = struct{}{}
}

// SigCleared returns if the "sig" field was cleared in this mutation.
func (m *EarthquakeMutation) SigCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldSig]
	return ok
}

// ResetSig resets all changes to the "sig" field.
func (m *EarthquakeMutation) ResetSig() {
	m.sig = nil
	m.addsig = nil
	delete(m.clearedFields, earthquake.FieldSig)
}

// SetNet sets the "net" field.
func (m *EarthquakeMutation) SetNet(s string) {
	m.net = &s
}

// Net returns the value of the "net" field in the mutation.
func (m *EarthquakeMutation) Net() (r string, exists bool) {
	v := m.net
	if v == nil {
		return
	}
	return *v, true
}

// OldNet returns the old "net" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldNet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNet: %w", err)
	}
	return oldValue.Net, nil
}

// ClearNet clears the value of the "net" field.
func (m *EarthquakeMutation) ClearNet() {
	m.net = nil
	m.clearedFields[earthquake.FieldNet] = struct{}{}
}

// NetCleared returns if the "net" field was cleared in this mutation.
func (m *EarthquakeMutation) NetCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldNet]
	return ok
}

// ResetNet resets all changes to the "net" field.
func (m *EarthquakeMutation) ResetNet() {
	m.net = nil
	delete(m.clearedFields, earthquake.FieldNet)
}

// SetCode sets the "code" field.
func (m *EarthquakeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *EarthquakeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *EarthquakeMutation) ClearCode() {
	m.code = nil
	m.clearedFields[earthquake.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *EarthquakeMutation) CodeCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *EarthquakeMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, earthquake.FieldCode)
}

// SetNst sets the "nst" field.
func (m *EarthquakeMutation) SetNst(i int32) {
	m.nst = &i
	m.addnst = nil
}

// Nst returns the value of the "nst" field in the mutation.
func (m *EarthquakeMutation) Nst() (r int32, exists bool) {
	v := m.nst
	if v == nil {
		return
	}
	return *v, true
}

// OldNst returns the old "nst" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldNst(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNst: %w", err)
	}
	return oldValue.Nst, nil
}

// AddNst adds i to the "nst" field.
func (m *EarthquakeMutation) AddNst(i int32) {
	if m.addnst != nil {
		*m.addnst += i
	} else {
		m.addnst = &i
	}
}

// AddedNst returns the value that was added to the "nst" field in this mutation.
func (m *EarthquakeMutation) AddedNst() (r int32, exists bool) {
	v := m.addnst
	if v == nil {
		return
	}
	return *v, true
}

// ClearNst clears the value of the "nst" field.
func (m *EarthquakeMutation) ClearNst() {
	m.nst = nil
	m.addnst = nil
	m.clearedFields[earthquake.FieldNst] = struct{}{}
}

// NstCleared returns if the "nst" field was cleared in this mutation.
func (m *EarthquakeMutation) NstCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldNst]
	return ok
}

// ResetNst resets all changes to the "nst" field.
func (m *EarthquakeMutation) ResetNst() {
	m.nst = nil
	m.addnst = nil
	delete(m.clearedFields, earthquake.FieldNst)
}

// SetDmin sets the "dmin" field.
func (m *EarthquakeMutation) SetDmin(f float64) {
	m.dmin = &f
	m.adddmin = nil
}

// Dmin returns the value of the "dmin" field in the mutation.
func (m *EarthquakeMutation) Dmin() (r float64, exists bool) {
	v := m.dmin
	if v == nil {
		return
	}
	return *v, true
}

// OldDmin returns the old "dmin" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldDmin(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDmin: %w", err)
	}
	return oldValue.Dmin, nil
}

// AddDmin adds f to the "dmin" field.
func (m *EarthquakeMutation) AddDmin(f float64) {
	if m.adddmin != nil {
		*m.adddmin += f
	} else {
		m.adddmin = &f
	}
}

// AddedDmin returns the value that was added to the "dmin" field in this mutation.
func (m *EarthquakeMutation) AddedDmin() (r float64, exists bool) {
	v := m.adddmin
	if v == nil {
		return
	}
	return *v, true
}

// ClearDmin clears the value of the "dmin" field.
func (m *EarthquakeMutation) ClearDmin() {
	m.dmin = nil
	m.adddmin = nil
	m.clearedFields[earthquake.FieldDmin] = struct{}{}
}

// DminCleared returns if the "dmin" field was cleared in this mutation.
func (m *EarthquakeMutation) DminCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldDmin]
	return ok
}

// ResetDmin resets all changes to the "dmin" field.
func (m *EarthquakeMutation) ResetDmin() {
	m.dmin = nil
	m.adddmin = nil
	delete(m.clearedFields, earthquake.FieldDmin)
}

// SetRms sets the "rms" field.
func (m *EarthquakeMutation) SetRms(f float64) {
	m.rms = &f
	m.addrms = nil
}

// Rms returns the value of the "rms" field in the mutation.
func (m *EarthquakeMutation) Rms() (r float64, exists bool) {
	v := m.rms
	if v == nil {
		return
	}
	return *v, true
}

// OldRms returns the old "rms" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldRms(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRms: %w", err)
	}
	return oldValue.Rms, nil
}

// AddRms adds f to the "rms" field.
func (m *EarthquakeMutation) AddRms(f float64) {
	if m.addrms != nil {
		*m.addrms += f
	} else {
		m.addrms = &f
	}
}

// AddedRms returns the value that was added to the "rms" field in this mutation.
func (m *EarthquakeMutation) AddedRms() (r float64, exists bool) {
	v := m.addrms
	if v == nil {
		return
	}
	return *v, true
}

// ClearRms clears the value of the "rms" field.
func (m *EarthquakeMutation) ClearRms() {
	m.rms = nil
	m.addrms = nil
	m.clearedFields[earthquake.FieldRms] = struct{}{}
}

// RmsCleared returns if the "rms" field was cleared in this mutation.
func (m *EarthquakeMutation) RmsCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldRms]
	return ok
}

// ResetRms resets all changes to the "rms" field.
func (m *EarthquakeMutation) ResetRms() {
	m.rms = nil
	m.addrms = nil
	delete(m.clearedFields, earthquake.FieldRms)
}

// SetGap sets the "gap" field.
func (m *EarthquakeMutation) SetGap(f float64) {
	m.gap = &f
	m.addgap = nil
}

// Gap returns the value of the "gap" field in the mutation.
func (m *EarthquakeMutation) Gap() (r float64, exists bool) {
	v := m.gap
	if v == nil {
		return
	}
	return *v, true
}

// OldGap returns the old "gap" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldGap(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGap is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGap requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGap: %w", err)
	}
	return oldValue.Gap, nil
}

// AddGap adds f to the "gap" field.
func (m *EarthquakeMutation) AddGap(f float64) {
	if m.addgap != nil {
		*m.addgap += f
	} else {
		m.addgap = &f
	}
}

// AddedGap returns the value that was added to the "gap" field in this mutation.
func (m *EarthquakeMutation) AddedGap() (r float64, exists bool) {
	v := m.addgap
	if v == nil {
		return
	}
	return *v, true
}

// ClearGap clears the value of the "gap" field.
func (m *EarthquakeMutation) ClearGap() {
	m.gap = nil
	m.addgap = nil
	m.clearedFields[earthquake.FieldGap] = struct{}{}
}

// GapCleared returns if the "gap" field was cleared in this mutation.
func (m *EarthquakeMutation) GapCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldGap]
	return ok
}

// ResetGap resets all changes to the "gap" field.
func (m *EarthquakeMutation) ResetGap() {
	m.gap = nil
	m.addgap = nil
	delete(m.clearedFields, earthquake.FieldGap)
}

// SetMagType sets the "mag_type" field.
func (m *EarthquakeMutation) SetMagType(s string) {
	m.mag_type = &s
}

// MagType returns the value of the "mag_type" field in the mutation.
func (m *EarthquakeMutation) MagType() (r string, exists bool) {
	v := m.mag_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMagType returns the old "mag_type" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldMagType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMagType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMagType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMagType: %w", err)
	}
	return oldValue.MagType, nil
}

// ClearMagType clears the value of the "mag_type" field.
func (m *EarthquakeMutation) ClearMagType() {
	m.mag_type = nil
	m.clearedFields[earthquake.FieldMagType] = struct{}{}
}

// MagTypeCleared returns if the "mag_type" field was cleared in this mutation.
func (m *EarthquakeMutation) MagTypeCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldMagType]
	return ok
}

// ResetMagType resets all changes to the "mag_type" field.
func (m *EarthquakeMutation) ResetMagType() {
	m.mag_type = nil
	delete(m.clearedFields, earthquake.FieldMagType)
}

// SetEqType sets the "eq_type" field.
func (m *EarthquakeMutation) SetEqType(s string) {
	m.eq_type = &s
}

// EqType returns the value of the "eq_type" field in the mutation.
func (m *EarthquakeMutation) EqType() (r string, exists bool) {
	v := m.eq_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEqType returns the old "eq_type" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldEqType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEqType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEqType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEqType: %w", err)
	}
	return oldValue.EqType, nil
}

// ClearEqType clears the value of the "eq_type" field.
func (m *EarthquakeMutation) ClearEqType() {
	m.eq_type = nil
	m.clearedFields[earthquake.FieldEqType] = struct{}{}
}

// EqTypeCleared returns if the "eq_type" field was cleared in this mutation.
func (m *EarthquakeMutation) EqTypeCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldEqType]
	return ok
}

// ResetEqType resets all changes to the "eq_type" field.
func (m *EarthquakeMutation) ResetEqType() {
	m.eq_type = nil
	delete(m.clearedFields, earthquake.FieldEqType)
}

// SetCreatedAt sets the "created_at" field.
func (m *EarthquakeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EarthquakeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EarthquakeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EarthquakeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EarthquakeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EarthquakeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EarthquakeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EarthquakeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Earthquake entity.
// If the Earthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EarthquakeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EarthquakeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[earthquake.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EarthquakeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[earthquake.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EarthquakeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, earthquake.FieldDeletedAt)
}

// SetGeometryID sets the "geometry" edge to the Geometry entity by id.
func (m *EarthquakeMutation) SetGeometryID(id int) {
	m.geometry = &id
}

// ClearGeometry clears the "geometry" edge to the Geometry entity.
func (m *EarthquakeMutation) ClearGeometry() {
	m.clearedgeometry = true
	m.clearedFields[earthquake.FieldGeoID] = struct{}{}
}

// GeometryCleared reports if the "geometry" edge to the Geometry entity was cleared.
func (m *EarthquakeMutation) GeometryCleared() bool {
	return m.GeoIDCleared() || m.clearedgeometry
}

// GeometryID returns the "geometry" edge ID in the mutation.
func (m *EarthquakeMutation) GeometryID() (id int, exists bool) {
	if m.geometry != nil {
		return *m.geometry, true
	}
	return
}

// GeometryIDs returns the "geometry" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GeometryID instead. It exists only for internal usage by the builders.
func (m *EarthquakeMutation) GeometryIDs() (ids []int) {
	if id := m.geometry; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGeometry resets all changes to the "geometry" edge.
func (m *EarthquakeMutation) ResetGeometry() {
	m.geometry = nil
	m.clearedgeometry = false
}

// ClearReport clears the "report" edge to the Report entity.
func (m *EarthquakeMutation) ClearReport() {
	m.clearedreport = true
	m.clearedFields[earthquake.FieldReportID] = struct{}{}
}

// ReportCleared reports if the "report" edge to the Report entity was cleared.
func (m *EarthquakeMutation) ReportCleared() bool {
	return m.ReportIDCleared() || m.clearedreport
}

// ReportIDs returns the "report" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReportID instead. It exists only for internal usage by the builders.
func (m *EarthquakeMutation) ReportIDs() (ids []int) {
	if id := m.report; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReport resets all changes to the "report" edge.
func (m *EarthquakeMutation) ResetReport() {
	m.report = nil
	m.clearedreport = false
}

// AddFtypeEarthquakeIDs adds the "ftype_earthquakes" edge to the FtypeEarthquake entity by ids.
func (m *EarthquakeMutation) AddFtypeEarthquakeIDs(ids ...int) {
	if m.ftype_earthquakes == nil {
		m.ftype_earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		m.ftype_earthquakes[ids[i]] = struct{}{}
	}
}

// ClearFtypeEarthquakes clears the "ftype_earthquakes" edge to the FtypeEarthquake entity.
func (m *EarthquakeMutation) ClearFtypeEarthquakes() {
	m.clearedftype_earthquakes = true
}

// FtypeEarthquakesCleared reports if the "ftype_earthquakes" edge to the FtypeEarthquake entity was cleared.
func (m *EarthquakeMutation) FtypeEarthquakesCleared() bool {
	return m.clearedftype_earthquakes
}

// RemoveFtypeEarthquakeIDs removes the "ftype_earthquakes" edge to the FtypeEarthquake entity by IDs.
func (m *EarthquakeMutation) RemoveFtypeEarthquakeIDs(ids ...int) {
	if m.removedftype_earthquakes == nil {
		m.removedftype_earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ftype_earthquakes, ids[i])
		m.removedftype_earthquakes[ids[i]] = struct{}{}
	}
}

// RemovedFtypeEarthquakes returns the removed IDs of the "ftype_earthquakes" edge to the FtypeEarthquake entity.
func (m *EarthquakeMutation) RemovedFtypeEarthquakesIDs() (ids []int) {
	for id := range m.removedftype_earthquakes {
		ids = append(ids, id)
	}
	return
}

// FtypeEarthquakesIDs returns the "ftype_earthquakes" edge IDs in the mutation.
func (m *EarthquakeMutation) FtypeEarthquakesIDs() (ids []int) {
	for id := range m.ftype_earthquakes {
		ids = append(ids, id)
	}
	return
}

// ResetFtypeEarthquakes resets all changes to the "ftype_earthquakes" edge.
func (m *EarthquakeMutation) ResetFtypeEarthquakes() {
	m.ftype_earthquakes = nil
	m.clearedftype_earthquakes = false
	m.removedftype_earthquakes = nil
}

// AddSourceEarthquakeIDs adds the "source_earthquakes" edge to the SourceEarthquake entity by ids.
func (m *EarthquakeMutation) AddSourceEarthquakeIDs(ids ...int) {
	if m.source_earthquakes == nil {
		m.source_earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		m.source_earthquakes[ids[i]] = struct{}{}
	}
}

// ClearSourceEarthquakes clears the "source_earthquakes" edge to the SourceEarthquake entity.
func (m *EarthquakeMutation) ClearSourceEarthquakes() {
	m.clearedsource_earthquakes = true
}

// SourceEarthquakesCleared reports if the "source_earthquakes" edge to the SourceEarthquake entity was cleared.
func (m *EarthquakeMutation) SourceEarthquakesCleared() bool {
	return m.clearedsource_earthquakes
}

// RemoveSourceEarthquakeIDs removes the "source_earthquakes" edge to the SourceEarthquake entity by IDs.
func (m *EarthquakeMutation) RemoveSourceEarthquakeIDs(ids ...int) {
	if m.removedsource_earthquakes == nil {
		m.removedsource_earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.source_earthquakes, ids[i])
		m.removedsource_earthquakes[ids[i]] = struct{}{}
	}
}

// RemovedSourceEarthquakes returns the removed IDs of the "source_earthquakes" edge to the SourceEarthquake entity.
func (m *EarthquakeMutation) RemovedSourceEarthquakesIDs() (ids []int) {
	for id := range m.removedsource_earthquakes {
		ids = append(ids, id)
	}
	return
}

// SourceEarthquakesIDs returns the "source_earthquakes" edge IDs in the mutation.
func (m *EarthquakeMutation) SourceEarthquakesIDs() (ids []int) {
	for id := range m.source_earthquakes {
		ids = append(ids, id)
	}
	return
}

// ResetSourceEarthquakes resets all changes to the "source_earthquakes" edge.
func (m *EarthquakeMutation) ResetSourceEarthquakes() {
	m.source_earthquakes = nil
	m.clearedsource_earthquakes = false
	m.removedsource_earthquakes = nil
}

// Where appends a list predicates to the EarthquakeMutation builder.
func (m *EarthquakeMutation) Where(ps ...predicate.Earthquake) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EarthquakeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EarthquakeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Earthquake, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EarthquakeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EarthquakeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Earthquake).
func (m *EarthquakeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EarthquakeMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.geometry != nil {
		fields = append(fields, earthquake.FieldGeoID)
	}
	if m.report != nil {
		fields = append(fields, earthquake.FieldReportID)
	}
	if m.mag != nil {
		fields = append(fields, earthquake.FieldMag)
	}
	if m.time != nil {
		fields = append(fields, earthquake.FieldTime)
	}
	if m.updated_time != nil {
		fields = append(fields, earthquake.FieldUpdatedTime)
	}
	if m.tz != nil {
		fields = append(fields, earthquake.FieldTz)
	}
	if m.url != nil {
		fields = append(fields, earthquake.FieldURL)
	}
	if m.detail != nil {
		fields = append(fields, earthquake.FieldDetail)
	}
	if m.status != nil {
		fields = append(fields, earthquake.FieldStatus)
	}
	if m.tsunami != nil {
		fields = append(fields, earthquake.FieldTsunami)
	}
	if m.sig != nil {
		fields = append(fields, earthquake.FieldSig)
	}
	if m.net != nil {
		fields = append(fields, earthquake.FieldNet)
	}
	if m.code != nil {
		fields = append(fields, earthquake.FieldCode)
	}
	if m.nst != nil {
		fields = append(fields, earthquake.FieldNst)
	}
	if m.dmin != nil {
		fields = append(fields, earthquake.FieldDmin)
	}
	if m.rms != nil {
		fields = append(fields, earthquake.FieldRms)
	}
	if m.gap != nil {
		fields = append(fields, earthquake.FieldGap)
	}
	if m.mag_type != nil {
		fields = append(fields, earthquake.FieldMagType)
	}
	if m.eq_type != nil {
		fields = append(fields, earthquake.FieldEqType)
	}
	if m.created_at != nil {
		fields = append(fields, earthquake.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, earthquake.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, earthquake.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EarthquakeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case earthquake.FieldGeoID:
		return m.GeoID()
	case earthquake.FieldReportID:
		return m.ReportID()
	case earthquake.FieldMag:
		return m.Mag()
	case earthquake.FieldTime:
		return m.Time()
	case earthquake.FieldUpdatedTime:
		return m.UpdatedTime()
	case earthquake.FieldTz:
		return m.Tz()
	case earthquake.FieldURL:
		return m.URL()
	case earthquake.FieldDetail:
		return m.Detail()
	case earthquake.FieldStatus:
		return m.Status()
	case earthquake.FieldTsunami:
		return m.Tsunami()
	case earthquake.FieldSig:
		return m.Sig()
	case earthquake.FieldNet:
		return m.Net()
	case earthquake.FieldCode:
		return m.Code()
	case earthquake.FieldNst:
		return m.Nst()
	case earthquake.FieldDmin:
		return m.Dmin()
	case earthquake.FieldRms:
		return m.Rms()
	case earthquake.FieldGap:
		return m.Gap()
	case earthquake.FieldMagType:
		return m.MagType()
	case earthquake.FieldEqType:
		return m.EqType()
	case earthquake.FieldCreatedAt:
		return m.CreatedAt()
	case earthquake.FieldUpdatedAt:
		return m.UpdatedAt()
	case earthquake.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EarthquakeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case earthquake.FieldGeoID:
		return m.OldGeoID(ctx)
	case earthquake.FieldReportID:
		return m.OldReportID(ctx)
	case earthquake.FieldMag:
		return m.OldMag(ctx)
	case earthquake.FieldTime:
		return m.OldTime(ctx)
	case earthquake.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	case earthquake.FieldTz:
		return m.OldTz(ctx)
	case earthquake.FieldURL:
		return m.OldURL(ctx)
	case earthquake.FieldDetail:
		return m.OldDetail(ctx)
	case earthquake.FieldStatus:
		return m.OldStatus(ctx)
	case earthquake.FieldTsunami:
		return m.OldTsunami(ctx)
	case earthquake.FieldSig:
		return m.OldSig(ctx)
	case earthquake.FieldNet:
		return m.OldNet(ctx)
	case earthquake.FieldCode:
		return m.OldCode(ctx)
	case earthquake.FieldNst:
		return m.OldNst(ctx)
	case earthquake.FieldDmin:
		return m.OldDmin(ctx)
	case earthquake.FieldRms:
		return m.OldRms(ctx)
	case earthquake.FieldGap:
		return m.OldGap(ctx)
	case earthquake.FieldMagType:
		return m.OldMagType(ctx)
	case earthquake.FieldEqType:
		return m.OldEqType(ctx)
	case earthquake.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case earthquake.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case earthquake.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Earthquake field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EarthquakeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case earthquake.FieldGeoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoID(v)
		return nil
	case earthquake.FieldReportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportID(v)
		return nil
	case earthquake.FieldMag:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMag(v)
		return nil
	case earthquake.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case earthquake.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	case earthquake.FieldTz:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTz(v)
		return nil
	case earthquake.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case earthquake.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case earthquake.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case earthquake.FieldTsunami:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTsunami(v)
		return nil
	case earthquake.FieldSig:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSig(v)
		return nil
	case earthquake.FieldNet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNet(v)
		return nil
	case earthquake.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case earthquake.FieldNst:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNst(v)
		return nil
	case earthquake.FieldDmin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDmin(v)
		return nil
	case earthquake.FieldRms:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRms(v)
		return nil
	case earthquake.FieldGap:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGap(v)
		return nil
	case earthquake.FieldMagType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMagType(v)
		return nil
	case earthquake.FieldEqType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEqType(v)
		return nil
	case earthquake.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case earthquake.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case earthquake.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Earthquake field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EarthquakeMutation) AddedFields() []string {
	var fields []string
	if m.addmag != nil {
		fields = append(fields, earthquake.FieldMag)
	}
	if m.addtz != nil {
		fields = append(fields, earthquake.FieldTz)
	}
	if m.addtsunami != nil {
		fields = append(fields, earthquake.FieldTsunami)
	}
	if m.addsig != nil {
		fields = append(fields, earthquake.FieldSig)
	}
	if m.addnst != nil {
		fields = append(fields, earthquake.FieldNst)
	}
	if m.adddmin != nil {
		fields = append(fields, earthquake.FieldDmin)
	}
	if m.addrms != nil {
		fields = append(fields, earthquake.FieldRms)
	}
	if m.addgap != nil {
		fields = append(fields, earthquake.FieldGap)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EarthquakeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case earthquake.FieldMag:
		return m.AddedMag()
	case earthquake.FieldTz:
		return m.AddedTz()
	case earthquake.FieldTsunami:
		return m.AddedTsunami()
	case earthquake.FieldSig:
		return m.AddedSig()
	case earthquake.FieldNst:
		return m.AddedNst()
	case earthquake.FieldDmin:
		return m.AddedDmin()
	case earthquake.FieldRms:
		return m.AddedRms()
	case earthquake.FieldGap:
		return m.AddedGap()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EarthquakeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case earthquake.FieldMag:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMag(v)
		return nil
	case earthquake.FieldTz:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTz(v)
		return nil
	case earthquake.FieldTsunami:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTsunami(v)
		return nil
	case earthquake.FieldSig:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSig(v)
		return nil
	case earthquake.FieldNst:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNst(v)
		return nil
	case earthquake.FieldDmin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDmin(v)
		return nil
	case earthquake.FieldRms:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRms(v)
		return nil
	case earthquake.FieldGap:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGap(v)
		return nil
	}
	return fmt.Errorf("unknown Earthquake numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EarthquakeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(earthquake.FieldGeoID) {
		fields = append(fields, earthquake.FieldGeoID)
	}
	if m.FieldCleared(earthquake.FieldReportID) {
		fields = append(fields, earthquake.FieldReportID)
	}
	if m.FieldCleared(earthquake.FieldUpdatedTime) {
		fields = append(fields, earthquake.FieldUpdatedTime)
	}
	if m.FieldCleared(earthquake.FieldTz) {
		fields = append(fields, earthquake.FieldTz)
	}
	if m.FieldCleared(earthquake.FieldURL) {
		fields = append(fields, earthquake.FieldURL)
	}
	if m.FieldCleared(earthquake.FieldDetail) {
		fields = append(fields, earthquake.FieldDetail)
	}
	if m.FieldCleared(earthquake.FieldStatus) {
		fields = append(fields, earthquake.FieldStatus)
	}
	if m.FieldCleared(earthquake.FieldTsunami) {
		fields = append(fields, earthquake.FieldTsunami)
	}
	if m.FieldCleared(earthquake.FieldSig) {
		fields = append(fields, earthquake.FieldSig)
	}
	if m.FieldCleared(earthquake.FieldNet) {
		fields = append(fields, earthquake.FieldNet)
	}
	if m.FieldCleared(earthquake.FieldCode) {
		fields = append(fields, earthquake.FieldCode)
	}
	if m.FieldCleared(earthquake.FieldNst) {
		fields = append(fields, earthquake.FieldNst)
	}
	if m.FieldCleared(earthquake.FieldDmin) {
		fields = append(fields, earthquake.FieldDmin)
	}
	if m.FieldCleared(earthquake.FieldRms) {
		fields = append(fields, earthquake.FieldRms)
	}
	if m.FieldCleared(earthquake.FieldGap) {
		fields = append(fields, earthquake.FieldGap)
	}
	if m.FieldCleared(earthquake.FieldMagType) {
		fields = append(fields, earthquake.FieldMagType)
	}
	if m.FieldCleared(earthquake.FieldEqType) {
		fields = append(fields, earthquake.FieldEqType)
	}
	if m.FieldCleared(earthquake.FieldDeletedAt) {
		fields = append(fields, earthquake.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EarthquakeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EarthquakeMutation) ClearField(name string) error {
	switch name {
	case earthquake.FieldGeoID:
		m.ClearGeoID()
		return nil
	case earthquake.FieldReportID:
		m.ClearReportID()
		return nil
	case earthquake.FieldUpdatedTime:
		m.ClearUpdatedTime()
		return nil
	case earthquake.FieldTz:
		m.ClearTz()
		return nil
	case earthquake.FieldURL:
		m.ClearURL()
		return nil
	case earthquake.FieldDetail:
		m.ClearDetail()
		return nil
	case earthquake.FieldStatus:
		m.ClearStatus()
		return nil
	case earthquake.FieldTsunami:
		m.ClearTsunami()
		return nil
	case earthquake.FieldSig:
		m.ClearSig()
		return nil
	case earthquake.FieldNet:
		m.ClearNet()
		return nil
	case earthquake.FieldCode:
		m.ClearCode()
		return nil
	case earthquake.FieldNst:
		m.ClearNst()
		return nil
	case earthquake.FieldDmin:
		m.ClearDmin()
		return nil
	case earthquake.FieldRms:
		m.ClearRms()
		return nil
	case earthquake.FieldGap:
		m.ClearGap()
		return nil
	case earthquake.FieldMagType:
		m.ClearMagType()
		return nil
	case earthquake.FieldEqType:
		m.ClearEqType()
		return nil
	case earthquake.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Earthquake nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EarthquakeMutation) ResetField(name string) error {
	switch name {
	case earthquake.FieldGeoID:
		m.ResetGeoID()
		return nil
	case earthquake.FieldReportID:
		m.ResetReportID()
		return nil
	case earthquake.FieldMag:
		m.ResetMag()
		return nil
	case earthquake.FieldTime:
		m.ResetTime()
		return nil
	case earthquake.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	case earthquake.FieldTz:
		m.ResetTz()
		return nil
	case earthquake.FieldURL:
		m.ResetURL()
		return nil
	case earthquake.FieldDetail:
		m.ResetDetail()
		return nil
	case earthquake.FieldStatus:
		m.ResetStatus()
		return nil
	case earthquake.FieldTsunami:
		m.ResetTsunami()
		return nil
	case earthquake.FieldSig:
		m.ResetSig()
		return nil
	case earthquake.FieldNet:
		m.ResetNet()
		return nil
	case earthquake.FieldCode:
		m.ResetCode()
		return nil
	case earthquake.FieldNst:
		m.ResetNst()
		return nil
	case earthquake.FieldDmin:
		m.ResetDmin()
		return nil
	case earthquake.FieldRms:
		m.ResetRms()
		return nil
	case earthquake.FieldGap:
		m.ResetGap()
		return nil
	case earthquake.FieldMagType:
		m.ResetMagType()
		return nil
	case earthquake.FieldEqType:
		m.ResetEqType()
		return nil
	case earthquake.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case earthquake.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case earthquake.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Earthquake field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EarthquakeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.geometry != nil {
		edges = append(edges, earthquake.EdgeGeometry)
	}
	if m.report != nil {
		edges = append(edges, earthquake.EdgeReport)
	}
	if m.ftype_earthquakes != nil {
		edges = append(edges, earthquake.EdgeFtypeEarthquakes)
	}
	if m.source_earthquakes != nil {
		edges = append(edges, earthquake.EdgeSourceEarthquakes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EarthquakeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case earthquake.EdgeGeometry:
		if id := m.geometry; id != nil {
			return []ent.Value{*id}
		}
	case earthquake.EdgeReport:
		if id := m.report; id != nil {
			return []ent.Value{*id}
		}
	case earthquake.EdgeFtypeEarthquakes:
		ids := make([]ent.Value, 0, len(m.ftype_earthquakes))
		for id := range m.ftype_earthquakes {
			ids = append(ids, id)
		}
		return ids
	case earthquake.EdgeSourceEarthquakes:
		ids := make([]ent.Value, 0, len(m.source_earthquakes))
		for id := range m.source_earthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EarthquakeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedftype_earthquakes != nil {
		edges = append(edges, earthquake.EdgeFtypeEarthquakes)
	}
	if m.removedsource_earthquakes != nil {
		edges = append(edges, earthquake.EdgeSourceEarthquakes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EarthquakeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case earthquake.EdgeFtypeEarthquakes:
		ids := make([]ent.Value, 0, len(m.removedftype_earthquakes))
		for id := range m.removedftype_earthquakes {
			ids = append(ids, id)
		}
		return ids
	case earthquake.EdgeSourceEarthquakes:
		ids := make([]ent.Value, 0, len(m.removedsource_earthquakes))
		for id := range m.removedsource_earthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EarthquakeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedgeometry {
		edges = append(edges, earthquake.EdgeGeometry)
	}
	if m.clearedreport {
		edges = append(edges, earthquake.EdgeReport)
	}
	if m.clearedftype_earthquakes {
		edges = append(edges, earthquake.EdgeFtypeEarthquakes)
	}
	if m.clearedsource_earthquakes {
		edges = append(edges, earthquake.EdgeSourceEarthquakes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EarthquakeMutation) EdgeCleared(name string) bool {
	switch name {
	case earthquake.EdgeGeometry:
		return m.clearedgeometry
	case earthquake.EdgeReport:
		return m.clearedreport
	case earthquake.EdgeFtypeEarthquakes:
		return m.clearedftype_earthquakes
	case earthquake.EdgeSourceEarthquakes:
		return m.clearedsource_earthquakes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EarthquakeMutation) ClearEdge(name string) error {
	switch name {
	case earthquake.EdgeGeometry:
		m.ClearGeometry()
		return nil
	case earthquake.EdgeReport:
		m.ClearReport()
		return nil
	}
	return fmt.Errorf("unknown Earthquake unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EarthquakeMutation) ResetEdge(name string) error {
	switch name {
	case earthquake.EdgeGeometry:
		m.ResetGeometry()
		return nil
	case earthquake.EdgeReport:
		m.ResetReport()
		return nil
	case earthquake.EdgeFtypeEarthquakes:
		m.ResetFtypeEarthquakes()
		return nil
	case earthquake.EdgeSourceEarthquakes:
		m.ResetSourceEarthquakes()
		return nil
	}
	return fmt.Errorf("unknown Earthquake edge %s", name)
}

// FeatureTypeMutation represents an operation that mutates the FeatureType nodes in the graph.
type FeatureTypeMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	feat_type                *string
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	clearedFields            map[string]struct{}
	ftype_earthquakes        map[int]struct{}
	removedftype_earthquakes map[int]struct{}
	clearedftype_earthquakes bool
	done                     bool
	oldValue                 func(context.Context) (*FeatureType, error)
	predicates               []predicate.FeatureType
}

var _ ent.Mutation = (*FeatureTypeMutation)(nil)

// featuretypeOption allows management of the mutation configuration using functional options.
type featuretypeOption func(*FeatureTypeMutation)

// newFeatureTypeMutation creates new mutation for the FeatureType entity.
func newFeatureTypeMutation(c config, op Op, opts ...featuretypeOption) *FeatureTypeMutation {
	m := &FeatureTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeFeatureType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatureTypeID sets the ID field of the mutation.
func withFeatureTypeID(id int) featuretypeOption {
	return func(m *FeatureTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *FeatureType
		)
		m.oldValue = func(ctx context.Context) (*FeatureType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeatureType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeatureType sets the old FeatureType of the mutation.
func withFeatureType(node *FeatureType) featuretypeOption {
	return func(m *FeatureTypeMutation) {
		m.oldValue = func(context.Context) (*FeatureType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatureTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatureTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeatureType entities.
func (m *FeatureTypeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeatureTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeatureTypeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeatureType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFeatType sets the "feat_type" field.
func (m *FeatureTypeMutation) SetFeatType(s string) {
	m.feat_type = &s
}

// FeatType returns the value of the "feat_type" field in the mutation.
func (m *FeatureTypeMutation) FeatType() (r string, exists bool) {
	v := m.feat_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatType returns the old "feat_type" field's value of the FeatureType entity.
// If the FeatureType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureTypeMutation) OldFeatType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatType: %w", err)
	}
	return oldValue.FeatType, nil
}

// ClearFeatType clears the value of the "feat_type" field.
func (m *FeatureTypeMutation) ClearFeatType() {
	m.feat_type = nil
	m.clearedFields[featuretype.FieldFeatType] = struct{}{}
}

// FeatTypeCleared returns if the "feat_type" field was cleared in this mutation.
func (m *FeatureTypeMutation) FeatTypeCleared() bool {
	_, ok := m.clearedFields[featuretype.FieldFeatType]
	return ok
}

// ResetFeatType resets all changes to the "feat_type" field.
func (m *FeatureTypeMutation) ResetFeatType() {
	m.feat_type = nil
	delete(m.clearedFields, featuretype.FieldFeatType)
}

// SetCreatedAt sets the "created_at" field.
func (m *FeatureTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeatureTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeatureType entity.
// If the FeatureType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeatureTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeatureTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeatureTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeatureType entity.
// If the FeatureType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeatureTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FeatureTypeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FeatureTypeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FeatureType entity.
// If the FeatureType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureTypeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FeatureTypeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[featuretype.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FeatureTypeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[featuretype.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FeatureTypeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, featuretype.FieldDeletedAt)
}

// AddFtypeEarthquakeIDs adds the "ftype_earthquakes" edge to the FtypeEarthquake entity by ids.
func (m *FeatureTypeMutation) AddFtypeEarthquakeIDs(ids ...int) {
	if m.ftype_earthquakes == nil {
		m.ftype_earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		m.ftype_earthquakes[ids[i]] = struct{}{}
	}
}

// ClearFtypeEarthquakes clears the "ftype_earthquakes" edge to the FtypeEarthquake entity.
func (m *FeatureTypeMutation) ClearFtypeEarthquakes() {
	m.clearedftype_earthquakes = true
}

// FtypeEarthquakesCleared reports if the "ftype_earthquakes" edge to the FtypeEarthquake entity was cleared.
func (m *FeatureTypeMutation) FtypeEarthquakesCleared() bool {
	return m.clearedftype_earthquakes
}

// RemoveFtypeEarthquakeIDs removes the "ftype_earthquakes" edge to the FtypeEarthquake entity by IDs.
func (m *FeatureTypeMutation) RemoveFtypeEarthquakeIDs(ids ...int) {
	if m.removedftype_earthquakes == nil {
		m.removedftype_earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ftype_earthquakes, ids[i])
		m.removedftype_earthquakes[ids[i]] = struct{}{}
	}
}

// RemovedFtypeEarthquakes returns the removed IDs of the "ftype_earthquakes" edge to the FtypeEarthquake entity.
func (m *FeatureTypeMutation) RemovedFtypeEarthquakesIDs() (ids []int) {
	for id := range m.removedftype_earthquakes {
		ids = append(ids, id)
	}
	return
}

// FtypeEarthquakesIDs returns the "ftype_earthquakes" edge IDs in the mutation.
func (m *FeatureTypeMutation) FtypeEarthquakesIDs() (ids []int) {
	for id := range m.ftype_earthquakes {
		ids = append(ids, id)
	}
	return
}

// ResetFtypeEarthquakes resets all changes to the "ftype_earthquakes" edge.
func (m *FeatureTypeMutation) ResetFtypeEarthquakes() {
	m.ftype_earthquakes = nil
	m.clearedftype_earthquakes = false
	m.removedftype_earthquakes = nil
}

// Where appends a list predicates to the FeatureTypeMutation builder.
func (m *FeatureTypeMutation) Where(ps ...predicate.FeatureType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeatureTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeatureTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeatureType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeatureTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeatureTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeatureType).
func (m *FeatureTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeatureTypeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.feat_type != nil {
		fields = append(fields, featuretype.FieldFeatType)
	}
	if m.created_at != nil {
		fields = append(fields, featuretype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, featuretype.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, featuretype.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeatureTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case featuretype.FieldFeatType:
		return m.FeatType()
	case featuretype.FieldCreatedAt:
		return m.CreatedAt()
	case featuretype.FieldUpdatedAt:
		return m.UpdatedAt()
	case featuretype.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeatureTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case featuretype.FieldFeatType:
		return m.OldFeatType(ctx)
	case featuretype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case featuretype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case featuretype.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FeatureType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case featuretype.FieldFeatType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatType(v)
		return nil
	case featuretype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case featuretype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case featuretype.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FeatureType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeatureTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeatureTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FeatureType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeatureTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(featuretype.FieldFeatType) {
		fields = append(fields, featuretype.FieldFeatType)
	}
	if m.FieldCleared(featuretype.FieldDeletedAt) {
		fields = append(fields, featuretype.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeatureTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatureTypeMutation) ClearField(name string) error {
	switch name {
	case featuretype.FieldFeatType:
		m.ClearFeatType()
		return nil
	case featuretype.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown FeatureType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeatureTypeMutation) ResetField(name string) error {
	switch name {
	case featuretype.FieldFeatType:
		m.ResetFeatType()
		return nil
	case featuretype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case featuretype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case featuretype.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown FeatureType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeatureTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.ftype_earthquakes != nil {
		edges = append(edges, featuretype.EdgeFtypeEarthquakes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeatureTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case featuretype.EdgeFtypeEarthquakes:
		ids := make([]ent.Value, 0, len(m.ftype_earthquakes))
		for id := range m.ftype_earthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeatureTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedftype_earthquakes != nil {
		edges = append(edges, featuretype.EdgeFtypeEarthquakes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeatureTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case featuretype.EdgeFtypeEarthquakes:
		ids := make([]ent.Value, 0, len(m.removedftype_earthquakes))
		for id := range m.removedftype_earthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeatureTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedftype_earthquakes {
		edges = append(edges, featuretype.EdgeFtypeEarthquakes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeatureTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case featuretype.EdgeFtypeEarthquakes:
		return m.clearedftype_earthquakes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeatureTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FeatureType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeatureTypeMutation) ResetEdge(name string) error {
	switch name {
	case featuretype.EdgeFtypeEarthquakes:
		m.ResetFtypeEarthquakes()
		return nil
	}
	return fmt.Errorf("unknown FeatureType edge %s", name)
}

// FtypeEarthquakeMutation represents an operation that mutates the FtypeEarthquake nodes in the graph.
type FtypeEarthquakeMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	clearedFields       map[string]struct{}
	earthquake          *int
	clearedearthquake   bool
	feature_type        *int
	clearedfeature_type bool
	done                bool
	oldValue            func(context.Context) (*FtypeEarthquake, error)
	predicates          []predicate.FtypeEarthquake
}

var _ ent.Mutation = (*FtypeEarthquakeMutation)(nil)

// ftypeearthquakeOption allows management of the mutation configuration using functional options.
type ftypeearthquakeOption func(*FtypeEarthquakeMutation)

// newFtypeEarthquakeMutation creates new mutation for the FtypeEarthquake entity.
func newFtypeEarthquakeMutation(c config, op Op, opts ...ftypeearthquakeOption) *FtypeEarthquakeMutation {
	m := &FtypeEarthquakeMutation{
		config:        c,
		op:            op,
		typ:           TypeFtypeEarthquake,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFtypeEarthquakeID sets the ID field of the mutation.
func withFtypeEarthquakeID(id int) ftypeearthquakeOption {
	return func(m *FtypeEarthquakeMutation) {
		var (
			err   error
			once  sync.Once
			value *FtypeEarthquake
		)
		m.oldValue = func(ctx context.Context) (*FtypeEarthquake, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FtypeEarthquake.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFtypeEarthquake sets the old FtypeEarthquake of the mutation.
func withFtypeEarthquake(node *FtypeEarthquake) ftypeearthquakeOption {
	return func(m *FtypeEarthquakeMutation) {
		m.oldValue = func(context.Context) (*FtypeEarthquake, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FtypeEarthquakeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FtypeEarthquakeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FtypeEarthquake entities.
func (m *FtypeEarthquakeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FtypeEarthquakeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FtypeEarthquakeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FtypeEarthquake.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFtID sets the "ft_id" field.
func (m *FtypeEarthquakeMutation) SetFtID(i int) {
	m.feature_type = &i
}

// FtID returns the value of the "ft_id" field in the mutation.
func (m *FtypeEarthquakeMutation) FtID() (r int, exists bool) {
	v := m.feature_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFtID returns the old "ft_id" field's value of the FtypeEarthquake entity.
// If the FtypeEarthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FtypeEarthquakeMutation) OldFtID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFtID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFtID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFtID: %w", err)
	}
	return oldValue.FtID, nil
}

// ClearFtID clears the value of the "ft_id" field.
func (m *FtypeEarthquakeMutation) ClearFtID() {
	m.feature_type = nil
	m.clearedFields[ftypeearthquake.FieldFtID] = struct{}{}
}

// FtIDCleared returns if the "ft_id" field was cleared in this mutation.
func (m *FtypeEarthquakeMutation) FtIDCleared() bool {
	_, ok := m.clearedFields[ftypeearthquake.FieldFtID]
	return ok
}

// ResetFtID resets all changes to the "ft_id" field.
func (m *FtypeEarthquakeMutation) ResetFtID() {
	m.feature_type = nil
	delete(m.clearedFields, ftypeearthquake.FieldFtID)
}

// SetEqID sets the "eq_id" field.
func (m *FtypeEarthquakeMutation) SetEqID(i int) {
	m.earthquake = &i
}

// EqID returns the value of the "eq_id" field in the mutation.
func (m *FtypeEarthquakeMutation) EqID() (r int, exists bool) {
	v := m.earthquake
	if v == nil {
		return
	}
	return *v, true
}

// OldEqID returns the old "eq_id" field's value of the FtypeEarthquake entity.
// If the FtypeEarthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FtypeEarthquakeMutation) OldEqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEqID: %w", err)
	}
	return oldValue.EqID, nil
}

// ClearEqID clears the value of the "eq_id" field.
func (m *FtypeEarthquakeMutation) ClearEqID() {
	m.earthquake = nil
	m.clearedFields[ftypeearthquake.FieldEqID] = struct{}{}
}

// EqIDCleared returns if the "eq_id" field was cleared in this mutation.
func (m *FtypeEarthquakeMutation) EqIDCleared() bool {
	_, ok := m.clearedFields[ftypeearthquake.FieldEqID]
	return ok
}

// ResetEqID resets all changes to the "eq_id" field.
func (m *FtypeEarthquakeMutation) ResetEqID() {
	m.earthquake = nil
	delete(m.clearedFields, ftypeearthquake.FieldEqID)
}

// SetCreatedAt sets the "created_at" field.
func (m *FtypeEarthquakeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FtypeEarthquakeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FtypeEarthquake entity.
// If the FtypeEarthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FtypeEarthquakeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FtypeEarthquakeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FtypeEarthquakeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FtypeEarthquakeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FtypeEarthquake entity.
// If the FtypeEarthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FtypeEarthquakeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FtypeEarthquakeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FtypeEarthquakeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FtypeEarthquakeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the FtypeEarthquake entity.
// If the FtypeEarthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FtypeEarthquakeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FtypeEarthquakeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[ftypeearthquake.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FtypeEarthquakeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[ftypeearthquake.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FtypeEarthquakeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, ftypeearthquake.FieldDeletedAt)
}

// SetEarthquakeID sets the "earthquake" edge to the Earthquake entity by id.
func (m *FtypeEarthquakeMutation) SetEarthquakeID(id int) {
	m.earthquake = &id
}

// ClearEarthquake clears the "earthquake" edge to the Earthquake entity.
func (m *FtypeEarthquakeMutation) ClearEarthquake() {
	m.clearedearthquake = true
	m.clearedFields[ftypeearthquake.FieldEqID] = struct{}{}
}

// EarthquakeCleared reports if the "earthquake" edge to the Earthquake entity was cleared.
func (m *FtypeEarthquakeMutation) EarthquakeCleared() bool {
	return m.EqIDCleared() || m.clearedearthquake
}

// EarthquakeID returns the "earthquake" edge ID in the mutation.
func (m *FtypeEarthquakeMutation) EarthquakeID() (id int, exists bool) {
	if m.earthquake != nil {
		return *m.earthquake, true
	}
	return
}

// EarthquakeIDs returns the "earthquake" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EarthquakeID instead. It exists only for internal usage by the builders.
func (m *FtypeEarthquakeMutation) EarthquakeIDs() (ids []int) {
	if id := m.earthquake; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEarthquake resets all changes to the "earthquake" edge.
func (m *FtypeEarthquakeMutation) ResetEarthquake() {
	m.earthquake = nil
	m.clearedearthquake = false
}

// SetFeatureTypeID sets the "feature_type" edge to the FeatureType entity by id.
func (m *FtypeEarthquakeMutation) SetFeatureTypeID(id int) {
	m.feature_type = &id
}

// ClearFeatureType clears the "feature_type" edge to the FeatureType entity.
func (m *FtypeEarthquakeMutation) ClearFeatureType() {
	m.clearedfeature_type = true
	m.clearedFields[ftypeearthquake.FieldFtID] = struct{}{}
}

// FeatureTypeCleared reports if the "feature_type" edge to the FeatureType entity was cleared.
func (m *FtypeEarthquakeMutation) FeatureTypeCleared() bool {
	return m.FtIDCleared() || m.clearedfeature_type
}

// FeatureTypeID returns the "feature_type" edge ID in the mutation.
func (m *FtypeEarthquakeMutation) FeatureTypeID() (id int, exists bool) {
	if m.feature_type != nil {
		return *m.feature_type, true
	}
	return
}

// FeatureTypeIDs returns the "feature_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeatureTypeID instead. It exists only for internal usage by the builders.
func (m *FtypeEarthquakeMutation) FeatureTypeIDs() (ids []int) {
	if id := m.feature_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeatureType resets all changes to the "feature_type" edge.
func (m *FtypeEarthquakeMutation) ResetFeatureType() {
	m.feature_type = nil
	m.clearedfeature_type = false
}

// Where appends a list predicates to the FtypeEarthquakeMutation builder.
func (m *FtypeEarthquakeMutation) Where(ps ...predicate.FtypeEarthquake) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FtypeEarthquakeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FtypeEarthquakeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FtypeEarthquake, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FtypeEarthquakeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FtypeEarthquakeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FtypeEarthquake).
func (m *FtypeEarthquakeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FtypeEarthquakeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.feature_type != nil {
		fields = append(fields, ftypeearthquake.FieldFtID)
	}
	if m.earthquake != nil {
		fields = append(fields, ftypeearthquake.FieldEqID)
	}
	if m.created_at != nil {
		fields = append(fields, ftypeearthquake.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ftypeearthquake.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, ftypeearthquake.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FtypeEarthquakeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ftypeearthquake.FieldFtID:
		return m.FtID()
	case ftypeearthquake.FieldEqID:
		return m.EqID()
	case ftypeearthquake.FieldCreatedAt:
		return m.CreatedAt()
	case ftypeearthquake.FieldUpdatedAt:
		return m.UpdatedAt()
	case ftypeearthquake.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FtypeEarthquakeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ftypeearthquake.FieldFtID:
		return m.OldFtID(ctx)
	case ftypeearthquake.FieldEqID:
		return m.OldEqID(ctx)
	case ftypeearthquake.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ftypeearthquake.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ftypeearthquake.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FtypeEarthquake field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FtypeEarthquakeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ftypeearthquake.FieldFtID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFtID(v)
		return nil
	case ftypeearthquake.FieldEqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEqID(v)
		return nil
	case ftypeearthquake.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ftypeearthquake.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ftypeearthquake.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FtypeEarthquake field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FtypeEarthquakeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FtypeEarthquakeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FtypeEarthquakeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FtypeEarthquake numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FtypeEarthquakeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ftypeearthquake.FieldFtID) {
		fields = append(fields, ftypeearthquake.FieldFtID)
	}
	if m.FieldCleared(ftypeearthquake.FieldEqID) {
		fields = append(fields, ftypeearthquake.FieldEqID)
	}
	if m.FieldCleared(ftypeearthquake.FieldDeletedAt) {
		fields = append(fields, ftypeearthquake.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FtypeEarthquakeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FtypeEarthquakeMutation) ClearField(name string) error {
	switch name {
	case ftypeearthquake.FieldFtID:
		m.ClearFtID()
		return nil
	case ftypeearthquake.FieldEqID:
		m.ClearEqID()
		return nil
	case ftypeearthquake.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown FtypeEarthquake nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FtypeEarthquakeMutation) ResetField(name string) error {
	switch name {
	case ftypeearthquake.FieldFtID:
		m.ResetFtID()
		return nil
	case ftypeearthquake.FieldEqID:
		m.ResetEqID()
		return nil
	case ftypeearthquake.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ftypeearthquake.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ftypeearthquake.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown FtypeEarthquake field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FtypeEarthquakeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.earthquake != nil {
		edges = append(edges, ftypeearthquake.EdgeEarthquake)
	}
	if m.feature_type != nil {
		edges = append(edges, ftypeearthquake.EdgeFeatureType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FtypeEarthquakeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ftypeearthquake.EdgeEarthquake:
		if id := m.earthquake; id != nil {
			return []ent.Value{*id}
		}
	case ftypeearthquake.EdgeFeatureType:
		if id := m.feature_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FtypeEarthquakeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FtypeEarthquakeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FtypeEarthquakeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedearthquake {
		edges = append(edges, ftypeearthquake.EdgeEarthquake)
	}
	if m.clearedfeature_type {
		edges = append(edges, ftypeearthquake.EdgeFeatureType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FtypeEarthquakeMutation) EdgeCleared(name string) bool {
	switch name {
	case ftypeearthquake.EdgeEarthquake:
		return m.clearedearthquake
	case ftypeearthquake.EdgeFeatureType:
		return m.clearedfeature_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FtypeEarthquakeMutation) ClearEdge(name string) error {
	switch name {
	case ftypeearthquake.EdgeEarthquake:
		m.ClearEarthquake()
		return nil
	case ftypeearthquake.EdgeFeatureType:
		m.ClearFeatureType()
		return nil
	}
	return fmt.Errorf("unknown FtypeEarthquake unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FtypeEarthquakeMutation) ResetEdge(name string) error {
	switch name {
	case ftypeearthquake.EdgeEarthquake:
		m.ResetEarthquake()
		return nil
	case ftypeearthquake.EdgeFeatureType:
		m.ResetFeatureType()
		return nil
	}
	return fmt.Errorf("unknown FtypeEarthquake edge %s", name)
}

// GeometryMutation represents an operation that mutates the Geometry nodes in the graph.
type GeometryMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	longitude          *float64
	addlongitude       *float64
	latitude           *float64
	addlatitude        *float64
	depth              *float64
	adddepth           *float64
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	clearedFields      map[string]struct{}
	earthquakes        map[int]struct{}
	removedearthquakes map[int]struct{}
	clearedearthquakes bool
	location           *int
	clearedlocation    bool
	done               bool
	oldValue           func(context.Context) (*Geometry, error)
	predicates         []predicate.Geometry
}

var _ ent.Mutation = (*GeometryMutation)(nil)

// geometryOption allows management of the mutation configuration using functional options.
type geometryOption func(*GeometryMutation)

// newGeometryMutation creates new mutation for the Geometry entity.
func newGeometryMutation(c config, op Op, opts ...geometryOption) *GeometryMutation {
	m := &GeometryMutation{
		config:        c,
		op:            op,
		typ:           TypeGeometry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGeometryID sets the ID field of the mutation.
func withGeometryID(id int) geometryOption {
	return func(m *GeometryMutation) {
		var (
			err   error
			once  sync.Once
			value *Geometry
		)
		m.oldValue = func(ctx context.Context) (*Geometry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Geometry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGeometry sets the old Geometry of the mutation.
func withGeometry(node *Geometry) geometryOption {
	return func(m *GeometryMutation) {
		m.oldValue = func(context.Context) (*Geometry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GeometryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GeometryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Geometry entities.
func (m *GeometryMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GeometryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GeometryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Geometry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLocationID sets the "location_id" field.
func (m *GeometryMutation) SetLocationID(i int) {
	m.location = &i
}

// LocationID returns the value of the "location_id" field in the mutation.
func (m *GeometryMutation) LocationID() (r int, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationID returns the old "location_id" field's value of the Geometry entity.
// If the Geometry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeometryMutation) OldLocationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationID: %w", err)
	}
	return oldValue.LocationID, nil
}

// ClearLocationID clears the value of the "location_id" field.
func (m *GeometryMutation) ClearLocationID() {
	m.location = nil
	m.clearedFields[geometry.FieldLocationID] = struct{}{}
}

// LocationIDCleared returns if the "location_id" field was cleared in this mutation.
func (m *GeometryMutation) LocationIDCleared() bool {
	_, ok := m.clearedFields[geometry.FieldLocationID]
	return ok
}

// ResetLocationID resets all changes to the "location_id" field.
func (m *GeometryMutation) ResetLocationID() {
	m.location = nil
	delete(m.clearedFields, geometry.FieldLocationID)
}

// SetLongitude sets the "longitude" field.
func (m *GeometryMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *GeometryMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Geometry entity.
// If the Geometry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeometryMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *GeometryMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *GeometryMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *GeometryMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
}

// SetLatitude sets the "latitude" field.
func (m *GeometryMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *GeometryMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Geometry entity.
// If the Geometry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeometryMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *GeometryMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *GeometryMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *GeometryMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
}

// SetDepth sets the "depth" field.
func (m *GeometryMutation) SetDepth(f float64) {
	m.depth = &f
	m.adddepth = nil
}

// Depth returns the value of the "depth" field in the mutation.
func (m *GeometryMutation) Depth() (r float64, exists bool) {
	v := m.depth
	if v == nil {
		return
	}
	return *v, true
}

// OldDepth returns the old "depth" field's value of the Geometry entity.
// If the Geometry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeometryMutation) OldDepth(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepth: %w", err)
	}
	return oldValue.Depth, nil
}

// AddDepth adds f to the "depth" field.
func (m *GeometryMutation) AddDepth(f float64) {
	if m.adddepth != nil {
		*m.adddepth += f
	} else {
		m.adddepth = &f
	}
}

// AddedDepth returns the value that was added to the "depth" field in this mutation.
func (m *GeometryMutation) AddedDepth() (r float64, exists bool) {
	v := m.adddepth
	if v == nil {
		return
	}
	return *v, true
}

// ResetDepth resets all changes to the "depth" field.
func (m *GeometryMutation) ResetDepth() {
	m.depth = nil
	m.adddepth = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GeometryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GeometryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Geometry entity.
// If the Geometry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeometryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GeometryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GeometryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GeometryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Geometry entity.
// If the Geometry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeometryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GeometryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GeometryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GeometryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Geometry entity.
// If the Geometry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeometryMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GeometryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[geometry.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GeometryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[geometry.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GeometryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, geometry.FieldDeletedAt)
}

// AddEarthquakeIDs adds the "earthquakes" edge to the Earthquake entity by ids.
func (m *GeometryMutation) AddEarthquakeIDs(ids ...int) {
	if m.earthquakes == nil {
		m.earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		m.earthquakes[ids[i]] = struct{}{}
	}
}

// ClearEarthquakes clears the "earthquakes" edge to the Earthquake entity.
func (m *GeometryMutation) ClearEarthquakes() {
	m.clearedearthquakes = true
}

// EarthquakesCleared reports if the "earthquakes" edge to the Earthquake entity was cleared.
func (m *GeometryMutation) EarthquakesCleared() bool {
	return m.clearedearthquakes
}

// RemoveEarthquakeIDs removes the "earthquakes" edge to the Earthquake entity by IDs.
func (m *GeometryMutation) RemoveEarthquakeIDs(ids ...int) {
	if m.removedearthquakes == nil {
		m.removedearthquakes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.earthquakes, ids[i])
		m.removedearthquakes[ids[i]] = struct{}{}
	}
}

// RemovedEarthquakes returns the removed IDs of the "earthquakes" edge to the Earthquake entity.
func (m *GeometryMutation) RemovedEarthquakesIDs() (ids []int) {
	for id := range m.removedearthquakes {
		ids = append(ids, id)
	}
	return
}

// EarthquakesIDs returns the "earthquakes" edge IDs in the mutation.
func (m *GeometryMutation) EarthquakesIDs() (ids []int) {
	for id := range m.earthquakes {
		ids = append(ids, id)
	}
	return
}

// ResetEarthquakes resets all changes to the "earthquakes" edge.
func (m *GeometryMutation) ResetEarthquakes() {
	m.earthquakes = nil
	m.clearedearthquakes = false
	m.removedearthquakes = nil
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *GeometryMutation) ClearLocation() {
	m.clearedlocation = true
	m.clearedFields[geometry.FieldLocationID] = struct{}{}
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *GeometryMutation) LocationCleared() bool {
	return m.LocationIDCleared() || m.clearedlocation
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *GeometryMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *GeometryMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// Where appends a list predicates to the GeometryMutation builder.
func (m *GeometryMutation) Where(ps ...predicate.Geometry) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GeometryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GeometryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Geometry, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GeometryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GeometryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Geometry).
func (m *GeometryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GeometryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.location != nil {
		fields = append(fields, geometry.FieldLocationID)
	}
	if m.longitude != nil {
		fields = append(fields, geometry.FieldLongitude)
	}
	if m.latitude != nil {
		fields = append(fields, geometry.FieldLatitude)
	}
	if m.depth != nil {
		fields = append(fields, geometry.FieldDepth)
	}
	if m.created_at != nil {
		fields = append(fields, geometry.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, geometry.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, geometry.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GeometryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case geometry.FieldLocationID:
		return m.LocationID()
	case geometry.FieldLongitude:
		return m.Longitude()
	case geometry.FieldLatitude:
		return m.Latitude()
	case geometry.FieldDepth:
		return m.Depth()
	case geometry.FieldCreatedAt:
		return m.CreatedAt()
	case geometry.FieldUpdatedAt:
		return m.UpdatedAt()
	case geometry.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GeometryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case geometry.FieldLocationID:
		return m.OldLocationID(ctx)
	case geometry.FieldLongitude:
		return m.OldLongitude(ctx)
	case geometry.FieldLatitude:
		return m.OldLatitude(ctx)
	case geometry.FieldDepth:
		return m.OldDepth(ctx)
	case geometry.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case geometry.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case geometry.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Geometry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GeometryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case geometry.FieldLocationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationID(v)
		return nil
	case geometry.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case geometry.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case geometry.FieldDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepth(v)
		return nil
	case geometry.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case geometry.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case geometry.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Geometry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GeometryMutation) AddedFields() []string {
	var fields []string
	if m.addlongitude != nil {
		fields = append(fields, geometry.FieldLongitude)
	}
	if m.addlatitude != nil {
		fields = append(fields, geometry.FieldLatitude)
	}
	if m.adddepth != nil {
		fields = append(fields, geometry.FieldDepth)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GeometryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case geometry.FieldLongitude:
		return m.AddedLongitude()
	case geometry.FieldLatitude:
		return m.AddedLatitude()
	case geometry.FieldDepth:
		return m.AddedDepth()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GeometryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case geometry.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case geometry.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case geometry.FieldDepth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepth(v)
		return nil
	}
	return fmt.Errorf("unknown Geometry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GeometryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(geometry.FieldLocationID) {
		fields = append(fields, geometry.FieldLocationID)
	}
	if m.FieldCleared(geometry.FieldDeletedAt) {
		fields = append(fields, geometry.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GeometryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GeometryMutation) ClearField(name string) error {
	switch name {
	case geometry.FieldLocationID:
		m.ClearLocationID()
		return nil
	case geometry.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Geometry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GeometryMutation) ResetField(name string) error {
	switch name {
	case geometry.FieldLocationID:
		m.ResetLocationID()
		return nil
	case geometry.FieldLongitude:
		m.ResetLongitude()
		return nil
	case geometry.FieldLatitude:
		m.ResetLatitude()
		return nil
	case geometry.FieldDepth:
		m.ResetDepth()
		return nil
	case geometry.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case geometry.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case geometry.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Geometry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GeometryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.earthquakes != nil {
		edges = append(edges, geometry.EdgeEarthquakes)
	}
	if m.location != nil {
		edges = append(edges, geometry.EdgeLocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GeometryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case geometry.EdgeEarthquakes:
		ids := make([]ent.Value, 0, len(m.earthquakes))
		for id := range m.earthquakes {
			ids = append(ids, id)
		}
		return ids
	case geometry.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GeometryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedearthquakes != nil {
		edges = append(edges, geometry.EdgeEarthquakes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GeometryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case geometry.EdgeEarthquakes:
		ids := make([]ent.Value, 0, len(m.removedearthquakes))
		for id := range m.removedearthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GeometryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedearthquakes {
		edges = append(edges, geometry.EdgeEarthquakes)
	}
	if m.clearedlocation {
		edges = append(edges, geometry.EdgeLocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GeometryMutation) EdgeCleared(name string) bool {
	switch name {
	case geometry.EdgeEarthquakes:
		return m.clearedearthquakes
	case geometry.EdgeLocation:
		return m.clearedlocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GeometryMutation) ClearEdge(name string) error {
	switch name {
	case geometry.EdgeLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown Geometry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GeometryMutation) ResetEdge(name string) error {
	switch name {
	case geometry.EdgeEarthquakes:
		m.ResetEarthquakes()
		return nil
	case geometry.EdgeLocation:
		m.ResetLocation()
		return nil
	}
	return fmt.Errorf("unknown Geometry edge %s", name)
}

// LocationMutation represents an operation that mutates the Location nodes in the graph.
type LocationMutation struct {
	config
	op                Op
	typ               string
	id                *int
	place             *string
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	clearedFields     map[string]struct{}
	geometries        map[int]struct{}
	removedgeometries map[int]struct{}
	clearedgeometries bool
	done              bool
	oldValue          func(context.Context) (*Location, error)
	predicates        []predicate.Location
}

var _ ent.Mutation = (*LocationMutation)(nil)

// locationOption allows management of the mutation configuration using functional options.
type locationOption func(*LocationMutation)

// newLocationMutation creates new mutation for the Location entity.
func newLocationMutation(c config, op Op, opts ...locationOption) *LocationMutation {
	m := &LocationMutation{
		config:        c,
		op:            op,
		typ:           TypeLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationID sets the ID field of the mutation.
func withLocationID(id int) locationOption {
	return func(m *LocationMutation) {
		var (
			err   error
			once  sync.Once
			value *Location
		)
		m.oldValue = func(ctx context.Context) (*Location, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Location.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocation sets the old Location of the mutation.
func withLocation(node *Location) locationOption {
	return func(m *LocationMutation) {
		m.oldValue = func(context.Context) (*Location, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Location entities.
func (m *LocationMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Location.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPlace sets the "place" field.
func (m *LocationMutation) SetPlace(s string) {
	m.place = &s
}

// Place returns the value of the "place" field in the mutation.
func (m *LocationMutation) Place() (r string, exists bool) {
	v := m.place
	if v == nil {
		return
	}
	return *v, true
}

// OldPlace returns the old "place" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldPlace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlace: %w", err)
	}
	return oldValue.Place, nil
}

// ClearPlace clears the value of the "place" field.
func (m *LocationMutation) ClearPlace() {
	m.place = nil
	m.clearedFields[location.FieldPlace] = struct{}{}
}

// PlaceCleared returns if the "place" field was cleared in this mutation.
func (m *LocationMutation) PlaceCleared() bool {
	_, ok := m.clearedFields[location.FieldPlace]
	return ok
}

// ResetPlace resets all changes to the "place" field.
func (m *LocationMutation) ResetPlace() {
	m.place = nil
	delete(m.clearedFields, location.FieldPlace)
}

// SetCreatedAt sets the "created_at" field.
func (m *LocationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LocationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LocationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LocationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LocationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LocationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *LocationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *LocationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *LocationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[location.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *LocationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[location.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *LocationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, location.FieldDeletedAt)
}

// AddGeometryIDs adds the "geometries" edge to the Geometry entity by ids.
func (m *LocationMutation) AddGeometryIDs(ids ...int) {
	if m.geometries == nil {
		m.geometries = make(map[int]struct{})
	}
	for i := range ids {
		m.geometries[ids[i]] = struct{}{}
	}
}

// ClearGeometries clears the "geometries" edge to the Geometry entity.
func (m *LocationMutation) ClearGeometries() {
	m.clearedgeometries = true
}

// GeometriesCleared reports if the "geometries" edge to the Geometry entity was cleared.
func (m *LocationMutation) GeometriesCleared() bool {
	return m.clearedgeometries
}

// RemoveGeometryIDs removes the "geometries" edge to the Geometry entity by IDs.
func (m *LocationMutation) RemoveGeometryIDs(ids ...int) {
	if m.removedgeometries == nil {
		m.removedgeometries = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.geometries, ids[i])
		m.removedgeometries[ids[i]] = struct{}{}
	}
}

// RemovedGeometries returns the removed IDs of the "geometries" edge to the Geometry entity.
func (m *LocationMutation) RemovedGeometriesIDs() (ids []int) {
	for id := range m.removedgeometries {
		ids = append(ids, id)
	}
	return
}

// GeometriesIDs returns the "geometries" edge IDs in the mutation.
func (m *LocationMutation) GeometriesIDs() (ids []int) {
	for id := range m.geometries {
		ids = append(ids, id)
	}
	return
}

// ResetGeometries resets all changes to the "geometries" edge.
func (m *LocationMutation) ResetGeometries() {
	m.geometries = nil
	m.clearedgeometries = false
	m.removedgeometries = nil
}

// Where appends a list predicates to the LocationMutation builder.
func (m *LocationMutation) Where(ps ...predicate.Location) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Location, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Location).
func (m *LocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.place != nil {
		fields = append(fields, location.FieldPlace)
	}
	if m.created_at != nil {
		fields = append(fields, location.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, location.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, location.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case location.FieldPlace:
		return m.Place()
	case location.FieldCreatedAt:
		return m.CreatedAt()
	case location.FieldUpdatedAt:
		return m.UpdatedAt()
	case location.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case location.FieldPlace:
		return m.OldPlace(ctx)
	case location.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case location.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case location.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Location field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case location.FieldPlace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlace(v)
		return nil
	case location.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case location.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case location.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Location numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(location.FieldPlace) {
		fields = append(fields, location.FieldPlace)
	}
	if m.FieldCleared(location.FieldDeletedAt) {
		fields = append(fields, location.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationMutation) ClearField(name string) error {
	switch name {
	case location.FieldPlace:
		m.ClearPlace()
		return nil
	case location.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Location nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationMutation) ResetField(name string) error {
	switch name {
	case location.FieldPlace:
		m.ResetPlace()
		return nil
	case location.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case location.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case location.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.geometries != nil {
		edges = append(edges, location.EdgeGeometries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeGeometries:
		ids := make([]ent.Value, 0, len(m.geometries))
		for id := range m.geometries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgeometries != nil {
		edges = append(edges, location.EdgeGeometries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeGeometries:
		ids := make([]ent.Value, 0, len(m.removedgeometries))
		for id := range m.removedgeometries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgeometries {
		edges = append(edges, location.EdgeGeometries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationMutation) EdgeCleared(name string) bool {
	switch name {
	case location.EdgeGeometries:
		return m.clearedgeometries
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Location unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationMutation) ResetEdge(name string) error {
	switch name {
	case location.EdgeGeometries:
		m.ResetGeometries()
		return nil
	}
	return fmt.Errorf("unknown Location edge %s", name)
}

// ReportMutation represents an operation that mutates the Report nodes in the graph.
type ReportMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	felt               *int32
	addfelt            *int32
	cdi                *float64
	addcdi             *float64
	mmi                *float64
	addmmi             *float64
	alert              *string
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	clearedFields      map[string]struct{}
	earthquakes        map[int]struct{}
	removedearthquakes map[int]struct{}
	clearedearthquakes bool
	done               bool
	oldValue           func(context.Context) (*Report, error)
	predicates         []predicate.Report
}

var _ ent.Mutation = (*ReportMutation)(nil)

// reportOption allows management of the mutation configuration using functional options.
type reportOption func(*ReportMutation)

// newReportMutation creates new mutation for the Report entity.
func newReportMutation(c config, op Op, opts ...reportOption) *ReportMutation {
	m := &ReportMutation{
		config:        c,
		op:            op,
		typ:           TypeReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReportID sets the ID field of the mutation.
func withReportID(id int) reportOption {
	return func(m *ReportMutation) {
		var (
			err   error
			once  sync.Once
			value *Report
		)
		m.oldValue = func(ctx context.Context) (*Report, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Report.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReport sets the old Report of the mutation.
func withReport(node *Report) reportOption {
	return func(m *ReportMutation) {
		m.oldValue = func(context.Context) (*Report, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Report entities.
func (m *ReportMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Report.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFelt sets the "felt" field.
func (m *ReportMutation) SetFelt(i int32) {
	m.felt = &i
	m.addfelt = nil
}

// Felt returns the value of the "felt" field in the mutation.
func (m *ReportMutation) Felt() (r int32, exists bool) {
	v := m.felt
	if v == nil {
		return
	}
	return *v, true
}

// OldFelt returns the old "felt" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldFelt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFelt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFelt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFelt: %w", err)
	}
	return oldValue.Felt, nil
}

// AddFelt adds i to the "felt" field.
func (m *ReportMutation) AddFelt(i int32) {
	if m.addfelt != nil {
		*m.addfelt += i
	} else {
		m.addfelt = &i
	}
}

// AddedFelt returns the value that was added to the "felt" field in this mutation.
func (m *ReportMutation) AddedFelt() (r int32, exists bool) {
	v := m.addfelt
	if v == nil {
		return
	}
	return *v, true
}

// ClearFelt clears the value of the "felt" field.
func (m *ReportMutation) ClearFelt() {
	m.felt = nil
	m.addfelt = nil
	m.clearedFields[report.FieldFelt] = struct{}{}
}

// FeltCleared returns if the "felt" field was cleared in this mutation.
func (m *ReportMutation) FeltCleared() bool {
	_, ok := m.clearedFields[report.FieldFelt]
	return ok
}

// ResetFelt resets all changes to the "felt" field.
func (m *ReportMutation) ResetFelt() {
	m.felt = nil
	m.addfelt = nil
	delete(m.clearedFields, report.FieldFelt)
}

// SetCdi sets the "cdi" field.
func (m *ReportMutation) SetCdi(f float64) {
	m.cdi = &f
	m.addcdi = nil
}

// Cdi returns the value of the "cdi" field in the mutation.
func (m *ReportMutation) Cdi() (r float64, exists bool) {
	v := m.cdi
	if v == nil {
		return
	}
	return *v, true
}

// OldCdi returns the old "cdi" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldCdi(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCdi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCdi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCdi: %w", err)
	}
	return oldValue.Cdi, nil
}

// AddCdi adds f to the "cdi" field.
func (m *ReportMutation) AddCdi(f float64) {
	if m.addcdi != nil {
		*m.addcdi += f
	} else {
		m.addcdi = &f
	}
}

// AddedCdi returns the value that was added to the "cdi" field in this mutation.
func (m *ReportMutation) AddedCdi() (r float64, exists bool) {
	v := m.addcdi
	if v == nil {
		return
	}
	return *v, true
}

// ClearCdi clears the value of the "cdi" field.
func (m *ReportMutation) ClearCdi() {
	m.cdi = nil
	m.addcdi = nil
	m.clearedFields[report.FieldCdi] = struct{}{}
}

// CdiCleared returns if the "cdi" field was cleared in this mutation.
func (m *ReportMutation) CdiCleared() bool {
	_, ok := m.clearedFields[report.FieldCdi]
	return ok
}

// ResetCdi resets all changes to the "cdi" field.
func (m *ReportMutation) ResetCdi() {
	m.cdi = nil
	m.addcdi = nil
	delete(m.clearedFields, report.FieldCdi)
}

// SetMmi sets the "mmi" field.
func (m *ReportMutation) SetMmi(f float64) {
	m.mmi = &f
	m.addmmi = nil
}

// Mmi returns the value of the "mmi" field in the mutation.
func (m *ReportMutation) Mmi() (r float64, exists bool) {
	v := m.mmi
	if v == nil {
		return
	}
	return *v, true
}

// OldMmi returns the old "mmi" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldMmi(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMmi is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMmi requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMmi: %w", err)
	}
	return oldValue.Mmi, nil
}

// AddMmi adds f to the "mmi" field.
func (m *ReportMutation) AddMmi(f float64) {
	if m.addmmi != nil {
		*m.addmmi += f
	} else {
		m.addmmi = &f
	}
}

// AddedMmi returns the value that was added to the "mmi" field in this mutation.
func (m *ReportMutation) AddedMmi() (r float64, exists bool) {
	v := m.addmmi
	if v == nil {
		return
	}
	return *v, true
}

// ClearMmi clears the value of the "mmi" field.
func (m *ReportMutation) ClearMmi() {
	m.mmi = nil
	m.addmmi = nil
	m.clearedFields[report.FieldMmi] = struct{}{}
}

// MmiCleared returns if the "mmi" field was cleared in this mutation.
func (m *ReportMutation) MmiCleared() bool {
	_, ok := m.clearedFields[report.FieldMmi]
	return ok
}

// ResetMmi resets all changes to the "mmi" field.
func (m *ReportMutation) ResetMmi() {
	m.mmi = nil
	m.addmmi = nil
	delete(m.clearedFields, report.FieldMmi)
}

// SetAlert sets the "alert" field.
func (m *ReportMutation) SetAlert(s string) {
	m.alert = &s
}

// Alert returns the value of the "alert" field in the mutation.
func (m *ReportMutation) Alert() (r string, exists bool) {
	v := m.alert
	if v == nil {
		return
	}
	return *v, true
}

// OldAlert returns the old "alert" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldAlert(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlert is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlert requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlert: %w", err)
	}
	return oldValue.Alert, nil
}

// ClearAlert clears the value of the "alert" field.
func (m *ReportMutation) ClearAlert() {
	m.alert = nil
	m.clearedFields[report.FieldAlert] = struct{}{}
}

// AlertCleared returns if the "alert" field was cleared in this mutation.
func (m *ReportMutation) AlertCleared() bool {
	_, ok := m.clearedFields[report.FieldAlert]
	return ok
}

// ResetAlert resets all changes to the "alert" field.
func (m *ReportMutation) ResetAlert() {
	m.alert = nil
	delete(m.clearedFields, report.FieldAlert)
}

// SetCreatedAt sets the "created_at" field.
func (m *ReportMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReportMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReportMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReportMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReportMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReportMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ReportMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ReportMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ReportMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[report.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ReportMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[report.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ReportMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, report.FieldDeletedAt)
}

// AddEarthquakeIDs adds the "earthquakes" edge to the Earthquake entity by ids.
func (m *ReportMutation) AddEarthquakeIDs(ids ...int) {
	if m.earthquakes == nil {
		m.earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		m.earthquakes[ids[i]] = struct{}{}
	}
}

// ClearEarthquakes clears the "earthquakes" edge to the Earthquake entity.
func (m *ReportMutation) ClearEarthquakes() {
	m.clearedearthquakes = true
}

// EarthquakesCleared reports if the "earthquakes" edge to the Earthquake entity was cleared.
func (m *ReportMutation) EarthquakesCleared() bool {
	return m.clearedearthquakes
}

// RemoveEarthquakeIDs removes the "earthquakes" edge to the Earthquake entity by IDs.
func (m *ReportMutation) RemoveEarthquakeIDs(ids ...int) {
	if m.removedearthquakes == nil {
		m.removedearthquakes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.earthquakes, ids[i])
		m.removedearthquakes[ids[i]] = struct{}{}
	}
}

// RemovedEarthquakes returns the removed IDs of the "earthquakes" edge to the Earthquake entity.
func (m *ReportMutation) RemovedEarthquakesIDs() (ids []int) {
	for id := range m.removedearthquakes {
		ids = append(ids, id)
	}
	return
}

// EarthquakesIDs returns the "earthquakes" edge IDs in the mutation.
func (m *ReportMutation) EarthquakesIDs() (ids []int) {
	for id := range m.earthquakes {
		ids = append(ids, id)
	}
	return
}

// ResetEarthquakes resets all changes to the "earthquakes" edge.
func (m *ReportMutation) ResetEarthquakes() {
	m.earthquakes = nil
	m.clearedearthquakes = false
	m.removedearthquakes = nil
}

// Where appends a list predicates to the ReportMutation builder.
func (m *ReportMutation) Where(ps ...predicate.Report) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Report, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Report).
func (m *ReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReportMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.felt != nil {
		fields = append(fields, report.FieldFelt)
	}
	if m.cdi != nil {
		fields = append(fields, report.FieldCdi)
	}
	if m.mmi != nil {
		fields = append(fields, report.FieldMmi)
	}
	if m.alert != nil {
		fields = append(fields, report.FieldAlert)
	}
	if m.created_at != nil {
		fields = append(fields, report.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, report.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, report.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case report.FieldFelt:
		return m.Felt()
	case report.FieldCdi:
		return m.Cdi()
	case report.FieldMmi:
		return m.Mmi()
	case report.FieldAlert:
		return m.Alert()
	case report.FieldCreatedAt:
		return m.CreatedAt()
	case report.FieldUpdatedAt:
		return m.UpdatedAt()
	case report.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case report.FieldFelt:
		return m.OldFelt(ctx)
	case report.FieldCdi:
		return m.OldCdi(ctx)
	case report.FieldMmi:
		return m.OldMmi(ctx)
	case report.FieldAlert:
		return m.OldAlert(ctx)
	case report.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case report.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case report.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Report field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case report.FieldFelt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFelt(v)
		return nil
	case report.FieldCdi:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCdi(v)
		return nil
	case report.FieldMmi:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMmi(v)
		return nil
	case report.FieldAlert:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlert(v)
		return nil
	case report.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case report.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case report.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Report field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReportMutation) AddedFields() []string {
	var fields []string
	if m.addfelt != nil {
		fields = append(fields, report.FieldFelt)
	}
	if m.addcdi != nil {
		fields = append(fields, report.FieldCdi)
	}
	if m.addmmi != nil {
		fields = append(fields, report.FieldMmi)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case report.FieldFelt:
		return m.AddedFelt()
	case report.FieldCdi:
		return m.AddedCdi()
	case report.FieldMmi:
		return m.AddedMmi()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case report.FieldFelt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFelt(v)
		return nil
	case report.FieldCdi:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCdi(v)
		return nil
	case report.FieldMmi:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMmi(v)
		return nil
	}
	return fmt.Errorf("unknown Report numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(report.FieldFelt) {
		fields = append(fields, report.FieldFelt)
	}
	if m.FieldCleared(report.FieldCdi) {
		fields = append(fields, report.FieldCdi)
	}
	if m.FieldCleared(report.FieldMmi) {
		fields = append(fields, report.FieldMmi)
	}
	if m.FieldCleared(report.FieldAlert) {
		fields = append(fields, report.FieldAlert)
	}
	if m.FieldCleared(report.FieldDeletedAt) {
		fields = append(fields, report.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReportMutation) ClearField(name string) error {
	switch name {
	case report.FieldFelt:
		m.ClearFelt()
		return nil
	case report.FieldCdi:
		m.ClearCdi()
		return nil
	case report.FieldMmi:
		m.ClearMmi()
		return nil
	case report.FieldAlert:
		m.ClearAlert()
		return nil
	case report.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Report nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReportMutation) ResetField(name string) error {
	switch name {
	case report.FieldFelt:
		m.ResetFelt()
		return nil
	case report.FieldCdi:
		m.ResetCdi()
		return nil
	case report.FieldMmi:
		m.ResetMmi()
		return nil
	case report.FieldAlert:
		m.ResetAlert()
		return nil
	case report.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case report.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case report.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Report field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.earthquakes != nil {
		edges = append(edges, report.EdgeEarthquakes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case report.EdgeEarthquakes:
		ids := make([]ent.Value, 0, len(m.earthquakes))
		for id := range m.earthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedearthquakes != nil {
		edges = append(edges, report.EdgeEarthquakes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReportMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case report.EdgeEarthquakes:
		ids := make([]ent.Value, 0, len(m.removedearthquakes))
		for id := range m.removedearthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedearthquakes {
		edges = append(edges, report.EdgeEarthquakes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReportMutation) EdgeCleared(name string) bool {
	switch name {
	case report.EdgeEarthquakes:
		return m.clearedearthquakes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReportMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Report unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReportMutation) ResetEdge(name string) error {
	switch name {
	case report.EdgeEarthquakes:
		m.ResetEarthquakes()
		return nil
	}
	return fmt.Errorf("unknown Report edge %s", name)
}

// SchemaMigrationMutation represents an operation that mutates the SchemaMigration nodes in the graph.
type SchemaMigrationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	dirty         *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SchemaMigration, error)
	predicates    []predicate.SchemaMigration
}

var _ ent.Mutation = (*SchemaMigrationMutation)(nil)

// schemamigrationOption allows management of the mutation configuration using functional options.
type schemamigrationOption func(*SchemaMigrationMutation)

// newSchemaMigrationMutation creates new mutation for the SchemaMigration entity.
func newSchemaMigrationMutation(c config, op Op, opts ...schemamigrationOption) *SchemaMigrationMutation {
	m := &SchemaMigrationMutation{
		config:        c,
		op:            op,
		typ:           TypeSchemaMigration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSchemaMigrationID sets the ID field of the mutation.
func withSchemaMigrationID(id int) schemamigrationOption {
	return func(m *SchemaMigrationMutation) {
		var (
			err   error
			once  sync.Once
			value *SchemaMigration
		)
		m.oldValue = func(ctx context.Context) (*SchemaMigration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SchemaMigration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchemaMigration sets the old SchemaMigration of the mutation.
func withSchemaMigration(node *SchemaMigration) schemamigrationOption {
	return func(m *SchemaMigrationMutation) {
		m.oldValue = func(context.Context) (*SchemaMigration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SchemaMigrationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SchemaMigrationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SchemaMigration entities.
func (m *SchemaMigrationMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SchemaMigrationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SchemaMigrationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SchemaMigration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDirty sets the "dirty" field.
func (m *SchemaMigrationMutation) SetDirty(b bool) {
	m.dirty = &b
}

// Dirty returns the value of the "dirty" field in the mutation.
func (m *SchemaMigrationMutation) Dirty() (r bool, exists bool) {
	v := m.dirty
	if v == nil {
		return
	}
	return *v, true
}

// OldDirty returns the old "dirty" field's value of the SchemaMigration entity.
// If the SchemaMigration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchemaMigrationMutation) OldDirty(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirty: %w", err)
	}
	return oldValue.Dirty, nil
}

// ResetDirty resets all changes to the "dirty" field.
func (m *SchemaMigrationMutation) ResetDirty() {
	m.dirty = nil
}

// Where appends a list predicates to the SchemaMigrationMutation builder.
func (m *SchemaMigrationMutation) Where(ps ...predicate.SchemaMigration) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SchemaMigrationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SchemaMigrationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SchemaMigration, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SchemaMigrationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SchemaMigrationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SchemaMigration).
func (m *SchemaMigrationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SchemaMigrationMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.dirty != nil {
		fields = append(fields, schemamigration.FieldDirty)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SchemaMigrationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schemamigration.FieldDirty:
		return m.Dirty()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SchemaMigrationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schemamigration.FieldDirty:
		return m.OldDirty(ctx)
	}
	return nil, fmt.Errorf("unknown SchemaMigration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchemaMigrationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schemamigration.FieldDirty:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirty(v)
		return nil
	}
	return fmt.Errorf("unknown SchemaMigration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SchemaMigrationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SchemaMigrationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchemaMigrationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SchemaMigration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SchemaMigrationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SchemaMigrationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SchemaMigrationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SchemaMigration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SchemaMigrationMutation) ResetField(name string) error {
	switch name {
	case schemamigration.FieldDirty:
		m.ResetDirty()
		return nil
	}
	return fmt.Errorf("unknown SchemaMigration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SchemaMigrationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SchemaMigrationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SchemaMigrationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SchemaMigrationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SchemaMigrationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SchemaMigrationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SchemaMigrationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SchemaMigration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SchemaMigrationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SchemaMigration edge %s", name)
}

// SourceMutation represents an operation that mutates the Source nodes in the graph.
type SourceMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	created_at                *time.Time
	updated_at                *time.Time
	deleted_at                *time.Time
	clearedFields             map[string]struct{}
	source_earthquakes        map[int]struct{}
	removedsource_earthquakes map[int]struct{}
	clearedsource_earthquakes bool
	done                      bool
	oldValue                  func(context.Context) (*Source, error)
	predicates                []predicate.Source
}

var _ ent.Mutation = (*SourceMutation)(nil)

// sourceOption allows management of the mutation configuration using functional options.
type sourceOption func(*SourceMutation)

// newSourceMutation creates new mutation for the Source entity.
func newSourceMutation(c config, op Op, opts ...sourceOption) *SourceMutation {
	m := &SourceMutation{
		config:        c,
		op:            op,
		typ:           TypeSource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceID sets the ID field of the mutation.
func withSourceID(id int) sourceOption {
	return func(m *SourceMutation) {
		var (
			err   error
			once  sync.Once
			value *Source
		)
		m.oldValue = func(ctx context.Context) (*Source, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Source.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSource sets the old Source of the mutation.
func withSource(node *Source) sourceOption {
	return func(m *SourceMutation) {
		m.oldValue = func(context.Context) (*Source, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Source entities.
func (m *SourceMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Source.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SourceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SourceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *SourceMutation) ClearName() {
	m.name = nil
	m.clearedFields[source.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *SourceMutation) NameCleared() bool {
	_, ok := m.clearedFields[source.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *SourceMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, source.FieldName)
}

// SetCreatedAt sets the "created_at" field.
func (m *SourceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SourceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SourceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SourceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SourceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SourceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SourceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SourceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Source entity.
// If the Source object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SourceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[source.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SourceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[source.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SourceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, source.FieldDeletedAt)
}

// AddSourceEarthquakeIDs adds the "source_earthquakes" edge to the SourceEarthquake entity by ids.
func (m *SourceMutation) AddSourceEarthquakeIDs(ids ...int) {
	if m.source_earthquakes == nil {
		m.source_earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		m.source_earthquakes[ids[i]] = struct{}{}
	}
}

// ClearSourceEarthquakes clears the "source_earthquakes" edge to the SourceEarthquake entity.
func (m *SourceMutation) ClearSourceEarthquakes() {
	m.clearedsource_earthquakes = true
}

// SourceEarthquakesCleared reports if the "source_earthquakes" edge to the SourceEarthquake entity was cleared.
func (m *SourceMutation) SourceEarthquakesCleared() bool {
	return m.clearedsource_earthquakes
}

// RemoveSourceEarthquakeIDs removes the "source_earthquakes" edge to the SourceEarthquake entity by IDs.
func (m *SourceMutation) RemoveSourceEarthquakeIDs(ids ...int) {
	if m.removedsource_earthquakes == nil {
		m.removedsource_earthquakes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.source_earthquakes, ids[i])
		m.removedsource_earthquakes[ids[i]] = struct{}{}
	}
}

// RemovedSourceEarthquakes returns the removed IDs of the "source_earthquakes" edge to the SourceEarthquake entity.
func (m *SourceMutation) RemovedSourceEarthquakesIDs() (ids []int) {
	for id := range m.removedsource_earthquakes {
		ids = append(ids, id)
	}
	return
}

// SourceEarthquakesIDs returns the "source_earthquakes" edge IDs in the mutation.
func (m *SourceMutation) SourceEarthquakesIDs() (ids []int) {
	for id := range m.source_earthquakes {
		ids = append(ids, id)
	}
	return
}

// ResetSourceEarthquakes resets all changes to the "source_earthquakes" edge.
func (m *SourceMutation) ResetSourceEarthquakes() {
	m.source_earthquakes = nil
	m.clearedsource_earthquakes = false
	m.removedsource_earthquakes = nil
}

// Where appends a list predicates to the SourceMutation builder.
func (m *SourceMutation) Where(ps ...predicate.Source) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Source, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Source).
func (m *SourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, source.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, source.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, source.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, source.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case source.FieldName:
		return m.Name()
	case source.FieldCreatedAt:
		return m.CreatedAt()
	case source.FieldUpdatedAt:
		return m.UpdatedAt()
	case source.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case source.FieldName:
		return m.OldName(ctx)
	case source.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case source.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case source.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Source field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case source.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case source.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case source.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case source.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Source field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Source numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(source.FieldName) {
		fields = append(fields, source.FieldName)
	}
	if m.FieldCleared(source.FieldDeletedAt) {
		fields = append(fields, source.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceMutation) ClearField(name string) error {
	switch name {
	case source.FieldName:
		m.ClearName()
		return nil
	case source.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Source nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceMutation) ResetField(name string) error {
	switch name {
	case source.FieldName:
		m.ResetName()
		return nil
	case source.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case source.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case source.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Source field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.source_earthquakes != nil {
		edges = append(edges, source.EdgeSourceEarthquakes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case source.EdgeSourceEarthquakes:
		ids := make([]ent.Value, 0, len(m.source_earthquakes))
		for id := range m.source_earthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsource_earthquakes != nil {
		edges = append(edges, source.EdgeSourceEarthquakes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case source.EdgeSourceEarthquakes:
		ids := make([]ent.Value, 0, len(m.removedsource_earthquakes))
		for id := range m.removedsource_earthquakes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsource_earthquakes {
		edges = append(edges, source.EdgeSourceEarthquakes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceMutation) EdgeCleared(name string) bool {
	switch name {
	case source.EdgeSourceEarthquakes:
		return m.clearedsource_earthquakes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Source unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceMutation) ResetEdge(name string) error {
	switch name {
	case source.EdgeSourceEarthquakes:
		m.ResetSourceEarthquakes()
		return nil
	}
	return fmt.Errorf("unknown Source edge %s", name)
}

// SourceEarthquakeMutation represents an operation that mutates the SourceEarthquake nodes in the graph.
type SourceEarthquakeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	clearedFields     map[string]struct{}
	earthquake        *int
	clearedearthquake bool
	source            *int
	clearedsource     bool
	done              bool
	oldValue          func(context.Context) (*SourceEarthquake, error)
	predicates        []predicate.SourceEarthquake
}

var _ ent.Mutation = (*SourceEarthquakeMutation)(nil)

// sourceearthquakeOption allows management of the mutation configuration using functional options.
type sourceearthquakeOption func(*SourceEarthquakeMutation)

// newSourceEarthquakeMutation creates new mutation for the SourceEarthquake entity.
func newSourceEarthquakeMutation(c config, op Op, opts ...sourceearthquakeOption) *SourceEarthquakeMutation {
	m := &SourceEarthquakeMutation{
		config:        c,
		op:            op,
		typ:           TypeSourceEarthquake,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSourceEarthquakeID sets the ID field of the mutation.
func withSourceEarthquakeID(id int) sourceearthquakeOption {
	return func(m *SourceEarthquakeMutation) {
		var (
			err   error
			once  sync.Once
			value *SourceEarthquake
		)
		m.oldValue = func(ctx context.Context) (*SourceEarthquake, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SourceEarthquake.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSourceEarthquake sets the old SourceEarthquake of the mutation.
func withSourceEarthquake(node *SourceEarthquake) sourceearthquakeOption {
	return func(m *SourceEarthquakeMutation) {
		m.oldValue = func(context.Context) (*SourceEarthquake, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceEarthquakeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceEarthquakeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SourceEarthquake entities.
func (m *SourceEarthquakeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SourceEarthquakeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SourceEarthquakeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SourceEarthquake.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSID sets the "s_id" field.
func (m *SourceEarthquakeMutation) SetSID(i int) {
	m.source = &i
}

// SID returns the value of the "s_id" field in the mutation.
func (m *SourceEarthquakeMutation) SID() (r int, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSID returns the old "s_id" field's value of the SourceEarthquake entity.
// If the SourceEarthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceEarthquakeMutation) OldSID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSID: %w", err)
	}
	return oldValue.SID, nil
}

// ClearSID clears the value of the "s_id" field.
func (m *SourceEarthquakeMutation) ClearSID() {
	m.source = nil
	m.clearedFields[sourceearthquake.FieldSID] = struct{}{}
}

// SIDCleared returns if the "s_id" field was cleared in this mutation.
func (m *SourceEarthquakeMutation) SIDCleared() bool {
	_, ok := m.clearedFields[sourceearthquake.FieldSID]
	return ok
}

// ResetSID resets all changes to the "s_id" field.
func (m *SourceEarthquakeMutation) ResetSID() {
	m.source = nil
	delete(m.clearedFields, sourceearthquake.FieldSID)
}

// SetEqID sets the "eq_id" field.
func (m *SourceEarthquakeMutation) SetEqID(i int) {
	m.earthquake = &i
}

// EqID returns the value of the "eq_id" field in the mutation.
func (m *SourceEarthquakeMutation) EqID() (r int, exists bool) {
	v := m.earthquake
	if v == nil {
		return
	}
	return *v, true
}

// OldEqID returns the old "eq_id" field's value of the SourceEarthquake entity.
// If the SourceEarthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceEarthquakeMutation) OldEqID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEqID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEqID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEqID: %w", err)
	}
	return oldValue.EqID, nil
}

// ClearEqID clears the value of the "eq_id" field.
func (m *SourceEarthquakeMutation) ClearEqID() {
	m.earthquake = nil
	m.clearedFields[sourceearthquake.FieldEqID] = struct{}{}
}

// EqIDCleared returns if the "eq_id" field was cleared in this mutation.
func (m *SourceEarthquakeMutation) EqIDCleared() bool {
	_, ok := m.clearedFields[sourceearthquake.FieldEqID]
	return ok
}

// ResetEqID resets all changes to the "eq_id" field.
func (m *SourceEarthquakeMutation) ResetEqID() {
	m.earthquake = nil
	delete(m.clearedFields, sourceearthquake.FieldEqID)
}

// SetCreatedAt sets the "created_at" field.
func (m *SourceEarthquakeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SourceEarthquakeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SourceEarthquake entity.
// If the SourceEarthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceEarthquakeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SourceEarthquakeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SourceEarthquakeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SourceEarthquakeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SourceEarthquake entity.
// If the SourceEarthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceEarthquakeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SourceEarthquakeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SourceEarthquakeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SourceEarthquakeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SourceEarthquake entity.
// If the SourceEarthquake object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SourceEarthquakeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SourceEarthquakeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[sourceearthquake.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SourceEarthquakeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[sourceearthquake.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SourceEarthquakeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, sourceearthquake.FieldDeletedAt)
}

// SetEarthquakeID sets the "earthquake" edge to the Earthquake entity by id.
func (m *SourceEarthquakeMutation) SetEarthquakeID(id int) {
	m.earthquake = &id
}

// ClearEarthquake clears the "earthquake" edge to the Earthquake entity.
func (m *SourceEarthquakeMutation) ClearEarthquake() {
	m.clearedearthquake = true
	m.clearedFields[sourceearthquake.FieldEqID] = struct{}{}
}

// EarthquakeCleared reports if the "earthquake" edge to the Earthquake entity was cleared.
func (m *SourceEarthquakeMutation) EarthquakeCleared() bool {
	return m.EqIDCleared() || m.clearedearthquake
}

// EarthquakeID returns the "earthquake" edge ID in the mutation.
func (m *SourceEarthquakeMutation) EarthquakeID() (id int, exists bool) {
	if m.earthquake != nil {
		return *m.earthquake, true
	}
	return
}

// EarthquakeIDs returns the "earthquake" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EarthquakeID instead. It exists only for internal usage by the builders.
func (m *SourceEarthquakeMutation) EarthquakeIDs() (ids []int) {
	if id := m.earthquake; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEarthquake resets all changes to the "earthquake" edge.
func (m *SourceEarthquakeMutation) ResetEarthquake() {
	m.earthquake = nil
	m.clearedearthquake = false
}

// SetSourceID sets the "source" edge to the Source entity by id.
func (m *SourceEarthquakeMutation) SetSourceID(id int) {
	m.source = &id
}

// ClearSource clears the "source" edge to the Source entity.
func (m *SourceEarthquakeMutation) ClearSource() {
	m.clearedsource = true
	m.clearedFields[sourceearthquake.FieldSID] = struct{}{}
}

// SourceCleared reports if the "source" edge to the Source entity was cleared.
func (m *SourceEarthquakeMutation) SourceCleared() bool {
	return m.SIDCleared() || m.clearedsource
}

// SourceID returns the "source" edge ID in the mutation.
func (m *SourceEarthquakeMutation) SourceID() (id int, exists bool) {
	if m.source != nil {
		return *m.source, true
	}
	return
}

// SourceIDs returns the "source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *SourceEarthquakeMutation) SourceIDs() (ids []int) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource resets all changes to the "source" edge.
func (m *SourceEarthquakeMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// Where appends a list predicates to the SourceEarthquakeMutation builder.
func (m *SourceEarthquakeMutation) Where(ps ...predicate.SourceEarthquake) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SourceEarthquakeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SourceEarthquakeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SourceEarthquake, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SourceEarthquakeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SourceEarthquakeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SourceEarthquake).
func (m *SourceEarthquakeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SourceEarthquakeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.source != nil {
		fields = append(fields, sourceearthquake.FieldSID)
	}
	if m.earthquake != nil {
		fields = append(fields, sourceearthquake.FieldEqID)
	}
	if m.created_at != nil {
		fields = append(fields, sourceearthquake.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sourceearthquake.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, sourceearthquake.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SourceEarthquakeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sourceearthquake.FieldSID:
		return m.SID()
	case sourceearthquake.FieldEqID:
		return m.EqID()
	case sourceearthquake.FieldCreatedAt:
		return m.CreatedAt()
	case sourceearthquake.FieldUpdatedAt:
		return m.UpdatedAt()
	case sourceearthquake.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SourceEarthquakeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sourceearthquake.FieldSID:
		return m.OldSID(ctx)
	case sourceearthquake.FieldEqID:
		return m.OldEqID(ctx)
	case sourceearthquake.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sourceearthquake.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sourceearthquake.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SourceEarthquake field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceEarthquakeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sourceearthquake.FieldSID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSID(v)
		return nil
	case sourceearthquake.FieldEqID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEqID(v)
		return nil
	case sourceearthquake.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sourceearthquake.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sourceearthquake.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SourceEarthquake field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SourceEarthquakeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SourceEarthquakeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SourceEarthquakeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SourceEarthquake numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SourceEarthquakeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sourceearthquake.FieldSID) {
		fields = append(fields, sourceearthquake.FieldSID)
	}
	if m.FieldCleared(sourceearthquake.FieldEqID) {
		fields = append(fields, sourceearthquake.FieldEqID)
	}
	if m.FieldCleared(sourceearthquake.FieldDeletedAt) {
		fields = append(fields, sourceearthquake.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SourceEarthquakeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceEarthquakeMutation) ClearField(name string) error {
	switch name {
	case sourceearthquake.FieldSID:
		m.ClearSID()
		return nil
	case sourceearthquake.FieldEqID:
		m.ClearEqID()
		return nil
	case sourceearthquake.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SourceEarthquake nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SourceEarthquakeMutation) ResetField(name string) error {
	switch name {
	case sourceearthquake.FieldSID:
		m.ResetSID()
		return nil
	case sourceearthquake.FieldEqID:
		m.ResetEqID()
		return nil
	case sourceearthquake.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sourceearthquake.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sourceearthquake.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown SourceEarthquake field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SourceEarthquakeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.earthquake != nil {
		edges = append(edges, sourceearthquake.EdgeEarthquake)
	}
	if m.source != nil {
		edges = append(edges, sourceearthquake.EdgeSource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SourceEarthquakeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sourceearthquake.EdgeEarthquake:
		if id := m.earthquake; id != nil {
			return []ent.Value{*id}
		}
	case sourceearthquake.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SourceEarthquakeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SourceEarthquakeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SourceEarthquakeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedearthquake {
		edges = append(edges, sourceearthquake.EdgeEarthquake)
	}
	if m.clearedsource {
		edges = append(edges, sourceearthquake.EdgeSource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SourceEarthquakeMutation) EdgeCleared(name string) bool {
	switch name {
	case sourceearthquake.EdgeEarthquake:
		return m.clearedearthquake
	case sourceearthquake.EdgeSource:
		return m.clearedsource
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SourceEarthquakeMutation) ClearEdge(name string) error {
	switch name {
	case sourceearthquake.EdgeEarthquake:
		m.ClearEarthquake()
		return nil
	case sourceearthquake.EdgeSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown SourceEarthquake unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SourceEarthquakeMutation) ResetEdge(name string) error {
	switch name {
	case sourceearthquake.EdgeEarthquake:
		m.ResetEarthquake()
		return nil
	case sourceearthquake.EdgeSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown SourceEarthquake edge %s", name)
}
